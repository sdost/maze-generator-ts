{"version":3,"file":"index-CPbqS0kl.js","sources":["../../src/objects/maze-renderer.ts","../../src/objects/base-maze-cell.ts","../../src/objects/square-maze-cell.ts","../../src/objects/maze-wall.ts","../../src/data-structures/disjoint-set.ts","../../src/helpers/pseudo-random.ts","../../src/errors/maze-errors.ts","../../src/utils/config-validator.ts","../../src/objects/square-maze-grid.ts","../../src/workers/maze-worker-manager.ts","../../src/main.ts"],"sourcesContent":["import { MazeGrid, Solution, Position, MazeCell } from '../types/maze';\n\nexport class MazeRenderer {\n  private ctx: CanvasRenderingContext2D;\n  private cellSize: number = 0;\n  private offsetX: number = 0;\n  private offsetY: number = 0;\n\n  constructor(\n    private canvas: HTMLCanvasElement,\n    private maze: MazeGrid\n  ) {\n    const context = canvas.getContext('2d');\n    if (!context) {\n      throw new Error('Could not get canvas context');\n    }\n    this.ctx = context;\n    this.calculateDimensions();\n  }\n\n  public updateMaze(maze: MazeGrid): void {\n    this.maze = maze;\n    this.calculateDimensions();\n  }\n\n  private calculateDimensions(): void {\n    const padding = 20;\n    this.cellSize = Math.min(\n      (this.canvas.width - padding * 2) / this.maze.width,\n      (this.canvas.height - padding * 2) / this.maze.height\n    );\n    this.offsetX = (this.canvas.width - this.maze.width * this.cellSize) / 2;\n    this.offsetY = (this.canvas.height - this.maze.height * this.cellSize) / 2;\n  }\n\n  public render(): void {\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    this.drawMaze();\n  }\n\n  public renderSolution(solution: Solution): void {\n    this.render();\n    this.drawPath(solution.path, '#ff0000', 3);\n  }\n\n  public renderSolvingProgress(\n    currentPath: Position[],\n    openSet: Position[],\n    closedSet: Position[]\n  ): void {\n    // First render the base maze\n    this.render();\n\n    // Draw closed set (visited cells) in gray\n    this.drawCells(closedSet, '#cccccc', 0.5);\n\n    // Draw open set (frontier) in light green\n    this.drawCells(openSet, '#90EE90', 0.5);\n\n    // Draw current path in red\n    this.drawPath(currentPath, '#ff0000', 2);\n  }\n\n  private drawMaze(): void {\n    // Draw background\n    this.ctx.fillStyle = '#ffffff';\n    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n\n    // Draw cells and walls\n    for (let y = 0; y < this.maze.height; y++) {\n      for (let x = 0; x < this.maze.width; x++) {\n        const cell = this.maze.getCell(x, y);\n        if (cell) {\n          this.drawCell(cell);\n        }\n      }\n    }\n\n    // Draw start and end cells\n    this.drawCell(this.maze.getStartCell(), '#00ff00');\n    this.drawCell(this.maze.getEndCell(), '#ff0000');\n  }\n\n  private drawCell(cell: MazeCell, color: string = '#000000'): void {\n    const { x, y } = cell.position;\n    const cellWidth = this.cellSize;\n    const cellHeight = this.cellSize;\n\n    // Draw cell background for start and end cells\n    if (cell === this.maze.getStartCell()) {\n      this.ctx.fillStyle = 'rgba(0, 255, 0, 0.2)'; // Light green tint\n      this.ctx.fillRect(\n        this.offsetX + x * cellWidth,\n        this.offsetY + y * cellHeight,\n        cellWidth,\n        cellHeight\n      );\n    } else if (cell === this.maze.getEndCell()) {\n      this.ctx.fillStyle = 'rgba(255, 0, 0, 0.2)'; // Light red tint\n      this.ctx.fillRect(\n        this.offsetX + x * cellWidth,\n        this.offsetY + y * cellHeight,\n        cellWidth,\n        cellHeight\n      );\n    }\n\n    // Draw walls\n    this.ctx.strokeStyle = color;\n    this.ctx.lineWidth = 2;\n\n    if (cell.hasWall(0)) {\n      // Top\n      this.ctx.beginPath();\n      this.ctx.moveTo(this.offsetX + x * cellWidth, this.offsetY + y * cellHeight);\n      this.ctx.lineTo(this.offsetX + (x + 1) * cellWidth, this.offsetY + y * cellHeight);\n      this.ctx.stroke();\n    }\n    if (cell.hasWall(1)) {\n      // Right\n      this.ctx.beginPath();\n      this.ctx.moveTo(this.offsetX + (x + 1) * cellWidth, this.offsetY + y * cellHeight);\n      this.ctx.lineTo(this.offsetX + (x + 1) * cellWidth, this.offsetY + (y + 1) * cellHeight);\n      this.ctx.stroke();\n    }\n    if (cell.hasWall(2)) {\n      // Bottom\n      this.ctx.beginPath();\n      this.ctx.moveTo(this.offsetX + x * cellWidth, this.offsetY + (y + 1) * cellHeight);\n      this.ctx.lineTo(this.offsetX + (x + 1) * cellWidth, this.offsetY + (y + 1) * cellHeight);\n      this.ctx.stroke();\n    }\n    if (cell.hasWall(3)) {\n      // Left\n      this.ctx.beginPath();\n      this.ctx.moveTo(this.offsetX + x * cellWidth, this.offsetY + y * cellHeight);\n      this.ctx.lineTo(this.offsetX + x * cellWidth, this.offsetY + (y + 1) * cellHeight);\n      this.ctx.stroke();\n    }\n  }\n\n  private drawPath(path: Position[], color: string, lineWidth: number): void {\n    if (path.length < 2) return;\n\n    this.ctx.strokeStyle = color;\n    this.ctx.lineWidth = lineWidth;\n    this.ctx.beginPath();\n\n    const start = path[0];\n    this.ctx.moveTo(\n      this.offsetX + (start.x + 0.5) * this.cellSize,\n      this.offsetY + (start.y + 0.5) * this.cellSize\n    );\n\n    for (let i = 1; i < path.length; i++) {\n      const point = path[i];\n      this.ctx.lineTo(\n        this.offsetX + (point.x + 0.5) * this.cellSize,\n        this.offsetY + (point.y + 0.5) * this.cellSize\n      );\n    }\n\n    this.ctx.stroke();\n  }\n\n  private drawCells(positions: Position[], color: string, alpha: number): void {\n    this.ctx.fillStyle = color;\n    this.ctx.globalAlpha = alpha;\n\n    for (const pos of positions) {\n      this.ctx.fillRect(\n        this.offsetX + pos.x * this.cellSize,\n        this.offsetY + pos.y * this.cellSize,\n        this.cellSize,\n        this.cellSize\n      );\n    }\n\n    this.ctx.globalAlpha = 1.0;\n  }\n}\n","import { Position, MazeCell } from '../types/maze';\n\nexport abstract class BaseMazeCell implements MazeCell {\n  private readonly _walls: boolean[];\n  private _visited: boolean = false;\n\n  constructor(\n    private readonly _position: Position,\n    wallCount: number\n  ) {\n    this._walls = new Array(wallCount).fill(true);\n  }\n\n  public get position(): Position {\n    return this._position;\n  }\n\n  public get walls(): ReadonlyArray<boolean> {\n    return this._walls;\n  }\n\n  public get visited(): boolean {\n    return this._visited;\n  }\n\n  public set visited(value: boolean) {\n    this._visited = value;\n  }\n\n  public removeWall(index: number): void {\n    if (index >= 0 && index < this._walls.length) {\n      this._walls[index] = false;\n    }\n  }\n\n  public hasWall(index: number): boolean {\n    return index >= 0 && index < this._walls.length ? this._walls[index] : false;\n  }\n\n  public equals(other: BaseMazeCell): boolean {\n    return this._position.x === other._position.x && this._position.y === other._position.y;\n  }\n\n  public toString(): string {\n    return `Cell(${this._position.x}, ${this._position.y})`;\n  }\n}\n","import { Position } from '../types/maze';\nimport { BaseMazeCell } from './base-maze-cell';\n\nexport enum SquareWall {\n  Top = 0,\n  Right = 1,\n  Bottom = 2,\n  Left = 3,\n}\n\nexport class SquareMazeCell extends BaseMazeCell {\n  private static readonly WALL_COUNT = 4;\n\n  constructor(position: Position) {\n    super(position, SquareMazeCell.WALL_COUNT);\n  }\n\n  public removeWall(wall: SquareWall): void {\n    super.removeWall(wall);\n  }\n\n  public hasWall(wall: SquareWall): boolean {\n    return super.hasWall(wall);\n  }\n\n  public getNeighborPosition(wall: SquareWall): Position {\n    const { x, y } = this.position;\n    switch (wall) {\n      case SquareWall.Top:\n        return { x, y: y - 1 };\n      case SquareWall.Right:\n        return { x: x + 1, y };\n      case SquareWall.Bottom:\n        return { x, y: y + 1 };\n      case SquareWall.Left:\n        return { x: x - 1, y };\n      default:\n        throw new Error(`Invalid wall direction: ${wall}`);\n    }\n  }\n\n  public static getOppositeWall(wall: SquareWall): SquareWall {\n    switch (wall) {\n      case SquareWall.Top:\n        return SquareWall.Bottom;\n      case SquareWall.Right:\n        return SquareWall.Left;\n      case SquareWall.Bottom:\n        return SquareWall.Top;\n      case SquareWall.Left:\n        return SquareWall.Right;\n      default:\n        throw new Error(`Invalid wall direction: ${wall}`);\n    }\n  }\n}\n","import { SquareMazeCell } from './square-maze-cell';\n\ninterface MutableMazeWall extends MazeWall {\n  cellA: SquareMazeCell;\n  cellB: SquareMazeCell;\n}\n\nexport class MazeWall {\n  private static readonly wallPool: MazeWall[] = [];\n  private static readonly MAX_POOL_SIZE = 10000;\n\n  private constructor(\n    public readonly cellA: SquareMazeCell,\n    public readonly cellB: SquareMazeCell\n  ) {}\n\n  public static create(cellA: SquareMazeCell, cellB: SquareMazeCell): MazeWall {\n    if (this.wallPool.length > 0) {\n      const wall = this.wallPool.pop()! as MutableMazeWall;\n      wall.cellA = cellA;\n      wall.cellB = cellB;\n      return wall;\n    }\n    return new MazeWall(cellA, cellB);\n  }\n\n  public static release(wall: MazeWall): void {\n    if (this.wallPool.length < this.MAX_POOL_SIZE) {\n      this.wallPool.push(wall);\n    }\n  }\n\n  public equals(other: MazeWall): boolean {\n    return (\n      (this.cellA === other.cellA && this.cellB === other.cellB) ||\n      (this.cellA === other.cellB && this.cellB === other.cellA)\n    );\n  }\n\n  public toString(): string {\n    return `Wall(${this.cellA.toString()} - ${this.cellB.toString()})`;\n  }\n}\n","export class DisjointSet {\n  private parent: number[];\n  private rank: number[];\n\n  constructor(size: number) {\n    this.parent = Array.from({ length: size }, (_, i) => i);\n    this.rank = new Array(size).fill(0);\n  }\n\n  public createSet(x: number): void {\n    this.parent[x] = x;\n    this.rank[x] = 0;\n  }\n\n  public findSet(x: number): number {\n    if (x < 0 || x >= this.parent.length) {\n      throw new Error('Element not found in any set');\n    }\n\n    if (this.parent[x] !== x) {\n      this.parent[x] = this.findSet(this.parent[x]);\n    }\n\n    return this.parent[x];\n  }\n\n  public mergeSet(x: number, y: number): void {\n    const rootX = this.findSet(x);\n    const rootY = this.findSet(y);\n\n    if (rootX === rootY) {\n      return;\n    }\n\n    const rankX = this.rank[rootX];\n    const rankY = this.rank[rootY];\n\n    if (rankX < rankY) {\n      this.parent[rootX] = rootY;\n    } else if (rankX > rankY) {\n      this.parent[rootY] = rootX;\n    } else {\n      this.parent[rootY] = rootX;\n      this.rank[rootX] = rankX + 1;\n    }\n  }\n}\n","export class PseudoRandom {\n  private static readonly MULTIPLIER = 1664525;\n  private static readonly INCREMENT = 1013904223;\n  private static readonly MODULUS = 4294967296; // 2^32\n\n  private seed: number;\n\n  constructor(seed: string | number | null = Date.now()) {\n    if (seed === null) {\n      this.seed = Date.now();\n    } else if (typeof seed === 'string') {\n      // Convert string to number using a simple hash function\n      this.seed = this.hashString(seed);\n    } else {\n      this.seed = seed;\n    }\n  }\n\n  private hashString(str: string): number {\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n      const char = str.charCodeAt(i);\n      hash = (hash << 5) - hash + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    return Math.abs(hash);\n  }\n\n  public nextInt(): number {\n    this.seed =\n      (this.seed * PseudoRandom.MULTIPLIER + PseudoRandom.INCREMENT) % PseudoRandom.MODULUS;\n    return this.seed;\n  }\n\n  public nextIntRange(min: number, max: number): number {\n    const range = max - min + 1;\n    const maxValue = PseudoRandom.MODULUS - (PseudoRandom.MODULUS % range);\n    let value: number;\n    do {\n      value = this.nextInt();\n    } while (value >= maxValue);\n    return min + (value % range);\n  }\n\n  public nextDouble(): number {\n    return this.nextInt() / PseudoRandom.MODULUS;\n  }\n\n  public nextDoubleRange(min: number, max: number): number {\n    return min + this.nextDouble() * (max - min);\n  }\n}\n","export class MazeError extends Error {\n  constructor(\n    message: string,\n    public readonly code: string\n  ) {\n    super(message);\n    this.name = 'MazeError';\n  }\n}\n\nexport class MazeGenerationError extends MazeError {\n  constructor(message: string) {\n    super(message, 'MAZE_GENERATION_ERROR');\n    this.name = 'MazeGenerationError';\n  }\n}\n\nexport class MazeSolvingError extends MazeError {\n  constructor(message: string) {\n    super(message, 'MAZE_SOLVING_ERROR');\n    this.name = 'MazeSolvingError';\n  }\n}\n\nexport class MazeRenderingError extends MazeError {\n  constructor(message: string) {\n    super(message, 'MAZE_RENDERING_ERROR');\n    this.name = 'MazeRenderingError';\n  }\n}\n\nexport class InvalidConfigError extends MazeError {\n  constructor(message: string) {\n    super(message, 'INVALID_CONFIG_ERROR');\n    this.name = 'InvalidConfigError';\n  }\n}\n","import { MazeConfig } from '../types/maze';\nimport { InvalidConfigError } from '../errors/maze-errors';\n\nexport class ConfigValidator {\n  private static readonly MIN_DIMENSION = 2;\n  private static readonly MAX_DIMENSION = 1000;\n  private static readonly MIN_CELL_SIZE = 4;\n  private static readonly MAX_CELL_SIZE = 100;\n  private static readonly MIN_ANIMATION_SPEED = 1;\n  private static readonly MAX_ANIMATION_SPEED = 1000;\n\n  public static validate(config: MazeConfig): void {\n    this.validateDimensions(config);\n    this.validateCellSize(config);\n    this.validateAnimationSpeed(config);\n  }\n\n  private static validateDimensions(config: MazeConfig): void {\n    if (config.width < this.MIN_DIMENSION || config.width > this.MAX_DIMENSION) {\n      throw new InvalidConfigError(\n        `Width must be between ${this.MIN_DIMENSION} and ${this.MAX_DIMENSION}`\n      );\n    }\n\n    if (config.height < this.MIN_DIMENSION || config.height > this.MAX_DIMENSION) {\n      throw new InvalidConfigError(\n        `Height must be between ${this.MIN_DIMENSION} and ${this.MAX_DIMENSION}`\n      );\n    }\n  }\n\n  private static validateCellSize(config: MazeConfig): void {\n    if (config.cellSize < this.MIN_CELL_SIZE || config.cellSize > this.MAX_CELL_SIZE) {\n      throw new InvalidConfigError(\n        `Cell size must be between ${this.MIN_CELL_SIZE} and ${this.MAX_CELL_SIZE}`\n      );\n    }\n  }\n\n  private static validateAnimationSpeed(config: MazeConfig): void {\n    if (\n      config.animationSpeed < this.MIN_ANIMATION_SPEED ||\n      config.animationSpeed > this.MAX_ANIMATION_SPEED\n    ) {\n      throw new InvalidConfigError(\n        `Animation speed must be between ${this.MIN_ANIMATION_SPEED} and ${this.MAX_ANIMATION_SPEED}`\n      );\n    }\n  }\n}\n","import { MazeGrid } from '../types/maze';\nimport { SquareMazeCell, SquareWall } from './square-maze-cell';\nimport { MazeWall } from './maze-wall';\nimport { DisjointSet } from '../data-structures/disjoint-set';\nimport { PseudoRandom } from '../helpers/pseudo-random';\nimport { ConfigValidator } from '../utils/config-validator';\nimport { MazeConfig } from '../types/maze';\nimport { MazeGenerationError } from '../errors/maze-errors';\n\nexport class SquareMazeGrid implements MazeGrid {\n  private readonly _cells: SquareMazeCell[];\n  private readonly wallList: MazeWall[];\n  private readonly sets: DisjointSet;\n  private startCell: SquareMazeCell | null = null;\n  private endCell: SquareMazeCell | null = null;\n\n  constructor(config: MazeConfig) {\n    ConfigValidator.validate(config);\n    this._cells = new Array<SquareMazeCell>(config.width * config.height);\n    this.wallList = [];\n    this.sets = new DisjointSet(config.width * config.height);\n    this.initializeGrid(config);\n  }\n\n  public get cells(): ReadonlyArray<SquareMazeCell> {\n    return this._cells;\n  }\n\n  public get width(): number {\n    return this._cells.length > 0 ? Math.sqrt(this._cells.length) : 0;\n  }\n\n  public get height(): number {\n    return this.width;\n  }\n\n  public getCell(x: number, y: number): SquareMazeCell | null {\n    if (x < 0 || x >= this.width || y < 0 || y >= this.height) {\n      return null;\n    }\n    return this._cells[x + y * this.width];\n  }\n\n  public getStartCell(): SquareMazeCell {\n    if (!this.startCell) {\n      throw new MazeGenerationError('Start cell not set');\n    }\n    return this.startCell;\n  }\n\n  public getEndCell(): SquareMazeCell {\n    if (!this.endCell) {\n      throw new MazeGenerationError('End cell not set');\n    }\n    return this.endCell;\n  }\n\n  public setStartCell(cell: SquareMazeCell): void {\n    this.startCell = cell;\n  }\n\n  public setEndCell(cell: SquareMazeCell): void {\n    this.endCell = cell;\n  }\n\n  private initializeGrid(config: MazeConfig): void {\n    // Initialize cells\n    for (let y = 0; y < config.height; y++) {\n      for (let x = 0; x < config.width; x++) {\n        const cell = new SquareMazeCell({ x, y });\n        this._cells[x + y * config.width] = cell;\n        this.sets.createSet(x + y * config.width);\n      }\n    }\n\n    // Initialize walls\n    for (let y = 0; y < config.height; y++) {\n      for (let x = 0; x < config.width; x++) {\n        const cell = this.getCell(x, y)!;\n\n        // Add walls to neighbors\n        if (x < config.width - 1) {\n          const rightCell = this.getCell(x + 1, y)!;\n          this.addWall(cell, rightCell);\n        }\n        if (y < config.height - 1) {\n          const bottomCell = this.getCell(x, y + 1)!;\n          this.addWall(cell, bottomCell);\n        }\n      }\n    }\n  }\n\n  private addWall(cellA: SquareMazeCell, cellB: SquareMazeCell): void {\n    const wall = MazeWall.create(cellA, cellB);\n    if (!this.wallList.some((w) => w.equals(wall))) {\n      this.wallList.push(wall);\n    } else {\n      MazeWall.release(wall);\n    }\n  }\n\n  public iterate(): boolean {\n    if (this.wallList.length === 0) {\n      return true;\n    }\n\n    const wall = this.wallList.pop()!;\n    const cellAIndex = wall.cellA.position.x + wall.cellA.position.y * this.width;\n    const cellBIndex = wall.cellB.position.x + wall.cellB.position.y * this.width;\n    if (this.sets.findSet(cellAIndex) !== this.sets.findSet(cellBIndex)) {\n      this.sets.mergeSet(cellAIndex, cellBIndex);\n      this.removeWallsBetween(wall.cellA, wall.cellB);\n    }\n\n    MazeWall.release(wall);\n    return false;\n  }\n\n  private removeWallsBetween(cellA: SquareMazeCell, cellB: SquareMazeCell): void {\n    const { x: x1, y: y1 } = cellA.position;\n    const { x: x2, y: y2 } = cellB.position;\n\n    if (x1 === x2) {\n      if (y1 < y2) {\n        cellA.removeWall(SquareWall.Bottom);\n        cellB.removeWall(SquareWall.Top);\n      } else {\n        cellA.removeWall(SquareWall.Top);\n        cellB.removeWall(SquareWall.Bottom);\n      }\n    } else {\n      if (x1 < x2) {\n        cellA.removeWall(SquareWall.Right);\n        cellB.removeWall(SquareWall.Left);\n      } else {\n        cellA.removeWall(SquareWall.Left);\n        cellB.removeWall(SquareWall.Right);\n      }\n    }\n  }\n\n  public static generate(config: MazeConfig): SquareMazeGrid {\n    const grid = new SquareMazeGrid(config);\n    const prng = new PseudoRandom(config.seed);\n\n    // Shuffle walls using Fisher-Yates algorithm with seeded random\n    for (let i = grid.wallList.length - 1; i > 0; i--) {\n      const j = prng.nextIntRange(0, i);\n      [grid.wallList[i], grid.wallList[j]] = [grid.wallList[j], grid.wallList[i]];\n    }\n\n    // Create exit cells immediately\n    grid.createExitCells(prng);\n\n    return grid;\n  }\n\n  private createExitCells(prng: PseudoRandom): void {\n    const outerWall: SquareWall = prng.nextIntRange(0, 3);\n    let xPos = 0;\n    let yPos = 0;\n\n    // Set start cell\n    switch (outerWall) {\n      case SquareWall.Top:\n        xPos = prng.nextIntRange(0, this.width - 1);\n        yPos = 0;\n        break;\n      case SquareWall.Right:\n        yPos = prng.nextIntRange(0, this.height - 1);\n        xPos = this.width - 1;\n        break;\n      case SquareWall.Bottom:\n        xPos = prng.nextIntRange(0, this.width - 1);\n        yPos = this.height - 1;\n        break;\n      case SquareWall.Left:\n        yPos = prng.nextIntRange(0, this.height - 1);\n        xPos = 0;\n        break;\n    }\n\n    this.startCell = this.getCell(xPos, yPos);\n\n    // Set end cell on opposite wall\n    switch (outerWall) {\n      case SquareWall.Top:\n        xPos = prng.nextIntRange(0, this.width - 1);\n        yPos = this.height - 1;\n        break;\n      case SquareWall.Right:\n        yPos = prng.nextIntRange(0, this.height - 1);\n        xPos = 0;\n        break;\n      case SquareWall.Bottom:\n        xPos = prng.nextIntRange(0, this.width - 1);\n        yPos = 0;\n        break;\n      case SquareWall.Left:\n        yPos = prng.nextIntRange(0, this.height - 1);\n        xPos = this.width - 1;\n        break;\n    }\n\n    this.endCell = this.getCell(xPos, yPos);\n  }\n}\n","import { MazeConfig, Solution, Position } from '../types/maze';\nimport { MazeRenderer } from '../objects/maze-renderer';\nimport { SquareMazeGrid } from '../objects/square-maze-grid';\n\ninterface WorkerResponse {\n  type: 'progress' | 'complete' | 'error';\n  payload: {\n    type?: string;\n    currentState?: {\n      _cells: Array<{\n        position: Position;\n        walls: boolean[];\n      }>;\n      startCell?: { position: Position };\n      endCell?: { position: Position };\n    };\n    currentPath?: Position[];\n    openSet?: Position[];\n    closedSet?: Position[];\n    maze?: {\n      _cells: Array<{\n        position: Position;\n        walls: boolean[];\n      }>;\n      startCell?: { position: Position };\n      endCell?: { position: Position };\n    };\n    solution?: Solution;\n    message?: string;\n  };\n}\n\nexport class MazeWorkerManager {\n  private worker: Worker | null = null;\n  private renderer: MazeRenderer | null = null;\n  private currentConfig: MazeConfig | null = null;\n  private animationFrameId: number | null = null;\n  private isAnimating = false;\n  private isSolving = false;\n  public onGenerationComplete?: () => void;\n  public onSolveComplete?: () => void;\n  private onError?: (error: string) => void;\n\n  constructor(\n    private canvas: HTMLCanvasElement,\n    onError: (error: string) => void\n  ) {\n    this.onError = onError;\n    this.initializeWorker();\n  }\n\n  private initializeWorker(): void {\n    // Use a relative path that Vite will handle during build\n    this.worker = new Worker(new URL('./maze-worker.ts', import.meta.url), {\n      type: 'module',\n      name: 'maze-worker',\n    });\n    this.setupMessageHandler();\n  }\n\n  private setupMessageHandler(): void {\n    if (!this.worker) return;\n\n    this.worker.onmessage = (event: MessageEvent<WorkerResponse>): void => {\n      const { type, payload } = event.data;\n      switch (type) {\n        case 'progress':\n          this.handleProgress(payload);\n          break;\n        case 'complete':\n          this.handleComplete(payload);\n          break;\n        case 'error':\n          console.error('Worker error:', payload.message);\n          this.onError?.(payload.message || 'An error occurred during maze generation');\n          break;\n      }\n    };\n\n    this.worker.onerror = (error: ErrorEvent): void => {\n      console.error('Worker error event:', error);\n      this.onError?.(error.message || 'An error occurred in the worker');\n    };\n  }\n\n  private reconstructMaze(mazeData: WorkerResponse['payload']['currentState']): SquareMazeGrid {\n    if (!this.currentConfig) {\n      throw new Error('No current config available for maze reconstruction');\n    }\n\n    const maze = new SquareMazeGrid(this.currentConfig);\n\n    // Copy the cells and their walls\n    if (Array.isArray(mazeData?._cells)) {\n      for (let i = 0; i < mazeData._cells.length; i++) {\n        const cellData = mazeData._cells[i];\n        if (!cellData || !cellData.position) {\n          console.error('Invalid cell data at index', i, cellData);\n          continue;\n        }\n\n        const cell = maze.getCell(cellData.position.x, cellData.position.y);\n        if (cell && Array.isArray(cellData.walls)) {\n          // Remove walls that are not present in the original cell\n          for (let wall = 0; wall < 4; wall++) {\n            if (!cellData.walls[wall]) {\n              cell.removeWall(wall);\n            }\n          }\n        }\n      }\n    } else {\n      console.error('Invalid cells array in maze data:', mazeData?._cells);\n    }\n\n    // Set start and end cells\n    if (mazeData?.startCell?.position) {\n      const startCell = maze.getCell(mazeData.startCell.position.x, mazeData.startCell.position.y);\n      if (startCell) {\n        maze.setStartCell(startCell);\n      }\n    }\n\n    if (mazeData?.endCell?.position) {\n      const endCell = maze.getCell(mazeData.endCell.position.x, mazeData.endCell.position.y);\n      if (endCell) {\n        maze.setEndCell(endCell);\n      }\n    }\n\n    return maze;\n  }\n\n  private handleProgress(payload: WorkerResponse['payload']): void {\n    const { type, currentState, currentPath, openSet, closedSet } = payload;\n\n    switch (type) {\n      case 'generate':\n        if (currentState) {\n          const maze = this.reconstructMaze(currentState);\n          if (!this.renderer) {\n            this.renderer = new MazeRenderer(this.canvas, maze);\n          } else {\n            this.renderer.updateMaze(maze);\n          }\n          this.renderer.render();\n        }\n        break;\n      case 'iterate':\n        if (currentState) {\n          const maze = this.reconstructMaze(currentState);\n          if (this.renderer) {\n            this.renderer.updateMaze(maze);\n            this.renderer.render();\n          }\n        }\n        break;\n      case 'solve':\n      case 'iterateSolution':\n        if (this.renderer && currentPath && openSet && closedSet) {\n          this.renderer.renderSolvingProgress(currentPath, openSet, closedSet);\n        }\n        break;\n    }\n  }\n\n  private handleComplete(payload: WorkerResponse['payload']): void {\n    const { type, maze, solution } = payload;\n\n    switch (type) {\n      case 'generate':\n        if (maze) {\n          const reconstructedMaze = this.reconstructMaze(maze);\n          if (!this.renderer) {\n            this.renderer = new MazeRenderer(this.canvas, reconstructedMaze);\n          } else {\n            this.renderer.updateMaze(reconstructedMaze);\n          }\n          this.renderer.render();\n          this.isAnimating = false;\n          if (this.animationFrameId !== null) {\n            cancelAnimationFrame(this.animationFrameId);\n            this.animationFrameId = null;\n          }\n          if (this.onGenerationComplete) {\n            this.onGenerationComplete();\n          }\n        }\n        break;\n      case 'solve':\n        if (solution && this.renderer) {\n          this.renderer.renderSolution(solution);\n          this.isSolving = false;\n          if (this.animationFrameId !== null) {\n            cancelAnimationFrame(this.animationFrameId);\n            this.animationFrameId = null;\n          }\n          if (this.onSolveComplete) {\n            this.onSolveComplete();\n          }\n        }\n        break;\n    }\n  }\n\n  public generateMaze(config: MazeConfig): void {\n    this.currentConfig = config;\n    this.isAnimating = true;\n    this.worker?.postMessage({ type: 'generate', payload: config });\n    this.startAnimation();\n  }\n\n  private startAnimation(): void {\n    if (this.animationFrameId !== null) {\n      cancelAnimationFrame(this.animationFrameId);\n    }\n\n    const animate = (): void => {\n      if (this.isAnimating) {\n        this.worker?.postMessage({ type: 'iterate' });\n        this.animationFrameId = requestAnimationFrame(animate);\n      }\n    };\n\n    this.animationFrameId = requestAnimationFrame(animate);\n  }\n\n  public solveMaze(): void {\n    if (this.isSolving) {\n      return;\n    }\n    this.isSolving = true;\n    this.worker?.postMessage({ type: 'solve' });\n    this.startSolvingAnimation();\n  }\n\n  private startSolvingAnimation(): void {\n    if (this.animationFrameId !== null) {\n      cancelAnimationFrame(this.animationFrameId);\n    }\n\n    const animate = (): void => {\n      if (this.isSolving) {\n        this.worker?.postMessage({ type: 'iterateSolution' });\n        this.animationFrameId = requestAnimationFrame(animate);\n      }\n    };\n\n    this.animationFrameId = requestAnimationFrame(animate);\n  }\n\n  public terminate(): void {\n    if (this.animationFrameId !== null) {\n      cancelAnimationFrame(this.animationFrameId);\n      this.animationFrameId = null;\n    }\n    this.isAnimating = false;\n    this.isSolving = false;\n    this.worker?.terminate();\n  }\n}\n","import { MazeWorkerManager } from './workers/maze-worker-manager';\nimport { MazeGenerationError } from './errors/maze-errors';\n\nclass App {\n  private workerManager: MazeWorkerManager;\n  private isGenerating = false;\n  private isSolving = false;\n  private solveButton: HTMLButtonElement | null = null;\n\n  constructor() {\n    const canvas = document.getElementById('mazeCanvas') as HTMLCanvasElement;\n    if (!canvas) {\n      throw new Error('Canvas element not found');\n    }\n\n    // Set canvas size\n    canvas.width = 800;\n    canvas.height = 800;\n\n    this.workerManager = new MazeWorkerManager(canvas, (error: string): void => {\n      console.error('Worker error:', error);\n      if (error) {\n        alert(error);\n      }\n      this.isGenerating = false;\n      this.isSolving = false;\n      this.updateButtonStates();\n    });\n\n    // Add callback for maze generation completion\n    this.workerManager.onGenerationComplete = (): void => {\n      this.isGenerating = false;\n      this.updateButtonStates();\n    };\n\n    // Add callback for solve completion\n    this.workerManager.onSolveComplete = (): void => {\n      this.isSolving = false;\n      this.updateButtonStates();\n    };\n\n    this.setupEventListeners();\n  }\n\n  private setupEventListeners(): void {\n    const generateBtn = document.getElementById('generate');\n    this.solveButton = document.getElementById('solve') as HTMLButtonElement;\n\n    if (generateBtn) {\n      generateBtn.addEventListener('click', (): void => {\n        this.handleGenerate();\n      });\n    } else {\n      console.error('Generate button not found');\n    }\n    if (this.solveButton) {\n      this.solveButton.disabled = true;\n      this.solveButton.addEventListener('click', (): void => {\n        this.handleSolve();\n      });\n    } else {\n      console.error('Solve button not found');\n    }\n  }\n\n  private updateButtonStates(): void {\n    if (this.solveButton) {\n      this.solveButton.disabled = this.isGenerating || this.isSolving;\n    }\n  }\n\n  private handleGenerate(): void {\n    if (this.isGenerating || this.isSolving) {\n      return;\n    }\n\n    const width = parseInt((document.getElementById('width') as HTMLInputElement).value);\n    const height = parseInt((document.getElementById('height') as HTMLInputElement).value);\n    const seedInput = document.getElementById('seed') as HTMLInputElement;\n    const seed = seedInput.value.trim() || null;\n\n    if (isNaN(width) || isNaN(height)) {\n      alert('Please enter valid numbers for width and height');\n      return;\n    }\n\n    try {\n      this.isGenerating = true;\n      this.updateButtonStates();\n      this.workerManager.generateMaze({\n        width,\n        height,\n        seed,\n        algorithm: 'kruskal',\n        renderer: 'canvas',\n        animationSpeed: 100,\n        cellSize: 20,\n      });\n    } catch (error) {\n      console.error('Error in handleGenerate:', error);\n      this.isGenerating = false;\n      this.updateButtonStates();\n      alert(error instanceof Error ? error.message : 'Failed to generate maze');\n    }\n  }\n\n  private handleSolve(): void {\n    if (this.isGenerating || this.isSolving) {\n      return;\n    }\n\n    try {\n      this.isSolving = true;\n      this.updateButtonStates();\n      this.workerManager.solveMaze();\n    } catch (error) {\n      console.error('Error in handleSolve:', error);\n      this.isSolving = false;\n      this.updateButtonStates();\n      if (error instanceof MazeGenerationError) {\n        alert(error.message);\n      } else {\n        alert('Failed to solve maze');\n      }\n    }\n  }\n}\n\n// Initialize the app when the DOM is loaded\ndocument.addEventListener('DOMContentLoaded', (): void => {\n  new App();\n});\n"],"names":["MazeRenderer","constructor","canvas","maze","this","__publicField","context","getContext","Error","ctx","calculateDimensions","updateMaze","cellSize","Math","min","width","padding","height","offsetX","offsetY","render","clearRect","drawMaze","renderSolution","solution","drawPath","path","renderSolvingProgress","currentPath","openSet","closedSet","drawCells","fillStyle","fillRect","y","x","cell","getCell","drawCell","getStartCell","getEndCell","color","position","cellWidth","cellHeight","strokeStyle","lineWidth","hasWall","beginPath","moveTo","lineTo","stroke","length","start","i","point","positions","alpha","globalAlpha","pos","BaseMazeCell","_position","wallCount","_walls","Array","fill","walls","visited","_visited","value","removeWall","index","equals","other","toString","SquareWall","_SquareMazeCell","super","WALL_COUNT","wall","getNeighborPosition","getOppositeWall","SquareMazeCell","_MazeWall","cellA","cellB","create","wallPool","pop","release","MAX_POOL_SIZE","push","MazeWall","DisjointSet","size","parent","from","_","rank","createSet","findSet","mergeSet","rootX","rootY","rankX","rankY","_PseudoRandom","seed","Date","now","hashString","str","hash","charCodeAt","abs","nextInt","MULTIPLIER","INCREMENT","MODULUS","nextIntRange","max","range","maxValue","nextDouble","nextDoubleRange","PseudoRandom","MazeError","message","code","name","MazeGenerationError","InvalidConfigError","ConfigValidator","validate","config","validateDimensions","validateCellSize","validateAnimationSpeed","MIN_DIMENSION","MAX_DIMENSION","MIN_CELL_SIZE","MAX_CELL_SIZE","animationSpeed","MIN_ANIMATION_SPEED","MAX_ANIMATION_SPEED","SquareMazeGrid","_cells","wallList","sets","initializeGrid","cells","sqrt","startCell","endCell","setStartCell","setEndCell","rightCell","addWall","bottomCell","some","w","iterate","cellAIndex","cellBIndex","removeWallsBetween","x1","y1","x2","y2","Bottom","Top","Right","Left","generate","grid","prng","j","createExitCells","outerWall","xPos","yPos","MazeWorkerManager","onError","initializeWorker","worker","Worker","URL","url","type","setupMessageHandler","onmessage","event","payload","data","handleProgress","handleComplete","onerror","error","reconstructMaze","mazeData","currentConfig","isArray","cellData","currentState","renderer","reconstructedMaze","isAnimating","animationFrameId","cancelAnimationFrame","onGenerationComplete","isSolving","onSolveComplete","generateMaze","postMessage","startAnimation","animate","requestAnimationFrame","solveMaze","startSolvingAnimation","terminate","App","document","getElementById","workerManager","alert","isGenerating","updateButtonStates","setupEventListeners","generateBtn","solveButton","addEventListener","handleGenerate","disabled","handleSolve","parseInt","trim","isNaN","algorithm"],"mappings":"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"}