var t=Object.defineProperty,e=(e,s,i)=>((e,s,i)=>s in e?t(e,s,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[s]=i)(e,"symbol"!=typeof s?s+"":s,i);class s{constructor(t,s){this._position=t,e(this,"_walls"),e(this,"_visited",!1),this._walls=new Array(s).fill(!0)}get position(){return this._position}get walls(){return this._walls}get visited(){return this._visited}set visited(t){this._visited=t}removeWall(t){t>=0&&t<this._walls.length&&(this._walls[t]=!1)}hasWall(t){return t>=0&&t<this._walls.length&&this._walls[t]}equals(t){return this._position.x===t._position.x&&this._position.y===t._position.y}toString(){return`Cell(${this._position.x}, ${this._position.y})`}}var i=Object.defineProperty,l=(t=>(t[t.Top=0]="Top",t[t.Right=1]="Right",t[t.Bottom=2]="Bottom",t[t.Left=3]="Left",t))(l||{});const r=class t extends s{constructor(e){super(e,t.WALL_COUNT)}removeWall(t){super.removeWall(t)}hasWall(t){return super.hasWall(t)}getNeighborPosition(t){const{x:e,y:s}=this.position;switch(t){case 0:return{x:e,y:s-1};case 1:return{x:e+1,y:s};case 2:return{x:e,y:s+1};case 3:return{x:e-1,y:s};default:throw new Error(`Invalid wall direction: ${t}`)}}static getOppositeWall(t){switch(t){case 0:return 2;case 1:return 3;case 2:return 0;case 3:return 1;default:throw new Error(`Invalid wall direction: ${t}`)}}};((t,e,s)=>{e in t?i(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s})(r,"WALL_COUNT"+"",4);let n=r;var o=Object.defineProperty,a=(t,e,s)=>((t,e,s)=>e in t?o(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s)(t,"symbol"!=typeof e?e+"":e,s);const h=class t{constructor(t,e){this.cellA=t,this.cellB=e}static create(e,s){if(this.wallPool.length>0){const t=this.wallPool.pop();return t.cellA=e,t.cellB=s,t}return new t(e,s)}static release(t){this.wallPool.length<this.MAX_POOL_SIZE&&this.wallPool.push(t)}equals(t){return this.cellA===t.cellA&&this.cellB===t.cellB||this.cellA===t.cellB&&this.cellB===t.cellA}toString(){return`Wall(${this.cellA.toString()} - ${this.cellB.toString()})`}};a(h,"wallPool",[]),a(h,"MAX_POOL_SIZE",1e4);let c=h;var d=Object.defineProperty,u=(t,e,s)=>((t,e,s)=>e in t?d(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s)(t,"symbol"!=typeof e?e+"":e,s);class g{constructor(t){u(this,"parent"),u(this,"rank"),this.parent=Array.from({length:t},((t,e)=>e)),this.rank=new Array(t).fill(0)}createSet(t){this.parent[t]=t,this.rank[t]=0}findSet(t){if(t<0||t>=this.parent.length)throw new Error("Element not found in any set");return this.parent[t]!==t&&(this.parent[t]=this.findSet(this.parent[t])),this.parent[t]}mergeSet(t,e){const s=this.findSet(t),i=this.findSet(e);if(s===i)return;const l=this.rank[s],r=this.rank[i];l<r?this.parent[s]=i:l>r?this.parent[i]=s:(this.parent[i]=s,this.rank[s]=l+1)}}var p=Object.defineProperty,w=(t,e,s)=>((t,e,s)=>e in t?p(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s)(t,"symbol"!=typeof e?e+"":e,s);const f=class t{constructor(t=Date.now()){w(this,"seed"),this.seed=null===t?Date.now():"string"==typeof t?this.hashString(t):t}hashString(t){let e=0;for(let s=0;s<t.length;s++){e=(e<<5)-e+t.charCodeAt(s),e&=e}return Math.abs(e)}nextInt(){return this.seed=(this.seed*t.MULTIPLIER+t.INCREMENT)%t.MODULUS,this.seed}nextIntRange(e,s){const i=s-e+1,l=t.MODULUS-t.MODULUS%i;let r;do{r=this.nextInt()}while(r>=l);return e+r%i}nextDouble(){return this.nextInt()/t.MODULUS}nextDoubleRange(t,e){return t+this.nextDouble()*(e-t)}};w(f,"MULTIPLIER",1664525),w(f,"INCREMENT",1013904223),w(f,"MODULUS",4294967296);let S=f;class m extends Error{constructor(t,e){super(t),this.code=e,this.name="MazeError"}}class E extends m{constructor(t){super(t,"MAZE_GENERATION_ERROR"),this.name="MazeGenerationError"}}class I extends m{constructor(t){super(t,"MAZE_SOLVING_ERROR"),this.name="MazeSolvingError"}}class C extends m{constructor(t){super(t,"INVALID_CONFIG_ERROR"),this.name="InvalidConfigError"}}var b=Object.defineProperty,y=(t,e,s)=>((t,e,s)=>e in t?b(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s)(t,"symbol"!=typeof e?e+"":e,s);class _{static validate(t){this.validateDimensions(t),this.validateCellSize(t),this.validateAnimationSpeed(t)}static validateDimensions(t){if(t.width<this.MIN_DIMENSION||t.width>this.MAX_DIMENSION)throw new C(`Width must be between ${this.MIN_DIMENSION} and ${this.MAX_DIMENSION}`);if(t.height<this.MIN_DIMENSION||t.height>this.MAX_DIMENSION)throw new C(`Height must be between ${this.MIN_DIMENSION} and ${this.MAX_DIMENSION}`)}static validateCellSize(t){if(t.cellSize<this.MIN_CELL_SIZE||t.cellSize>this.MAX_CELL_SIZE)throw new C(`Cell size must be between ${this.MIN_CELL_SIZE} and ${this.MAX_CELL_SIZE}`)}static validateAnimationSpeed(t){if(t.animationSpeed<this.MIN_ANIMATION_SPEED||t.animationSpeed>this.MAX_ANIMATION_SPEED)throw new C(`Animation speed must be between ${this.MIN_ANIMATION_SPEED} and ${this.MAX_ANIMATION_SPEED}`)}}y(_,"MIN_DIMENSION",2),y(_,"MAX_DIMENSION",1e3),y(_,"MIN_CELL_SIZE",4),y(_,"MAX_CELL_SIZE",100),y(_,"MIN_ANIMATION_SPEED",1),y(_,"MAX_ANIMATION_SPEED",1e3);var v=Object.defineProperty,M=(t,e,s)=>((t,e,s)=>e in t?v(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s)(t,"symbol"!=typeof e?e+"":e,s);class N{constructor(t){M(this,"_cells"),M(this,"wallList"),M(this,"sets"),M(this,"startCell",null),M(this,"endCell",null),_.validate(t),this._cells=new Array(t.width*t.height),this.wallList=[],this.sets=new g(t.width*t.height),this.initializeGrid(t)}get cells(){return this._cells}get width(){return this._cells.length>0?Math.sqrt(this._cells.length):0}get height(){return this.width}getCell(t,e){return t<0||t>=this.width||e<0||e>=this.height?null:this._cells[t+e*this.width]}getStartCell(){if(!this.startCell)throw new E("Start cell not set");return this.startCell}getEndCell(){if(!this.endCell)throw new E("End cell not set");return this.endCell}setStartCell(t){this.startCell=t}setEndCell(t){this.endCell=t}initializeGrid(t){for(let e=0;e<t.height;e++)for(let s=0;s<t.width;s++){const i=new n({x:s,y:e});this._cells[s+e*t.width]=i,this.sets.createSet(s+e*t.width)}for(let e=0;e<t.height;e++)for(let s=0;s<t.width;s++){const i=this.getCell(s,e);if(s<t.width-1){const t=this.getCell(s+1,e);this.addWall(i,t)}if(e<t.height-1){const t=this.getCell(s,e+1);this.addWall(i,t)}}}addWall(t,e){const s=c.create(t,e);this.wallList.some((t=>t.equals(s)))?c.release(s):this.wallList.push(s)}iterate(){if(0===this.wallList.length)return!0;const t=this.wallList.pop(),e=t.cellA.position.x+t.cellA.position.y*this.width,s=t.cellB.position.x+t.cellB.position.y*this.width;return this.sets.findSet(e)!==this.sets.findSet(s)&&(this.sets.mergeSet(e,s),this.removeWallsBetween(t.cellA,t.cellB)),c.release(t),!1}removeWallsBetween(t,e){const{x:s,y:i}=t.position,{x:r,y:n}=e.position;s===r?i<n?(t.removeWall(l.Bottom),e.removeWall(l.Top)):(t.removeWall(l.Top),e.removeWall(l.Bottom)):s<r?(t.removeWall(l.Right),e.removeWall(l.Left)):(t.removeWall(l.Left),e.removeWall(l.Right))}static generate(t){const e=new N(t),s=new S(t.seed);for(let i=e.wallList.length-1;i>0;i--){const t=s.nextIntRange(0,i);[e.wallList[i],e.wallList[t]]=[e.wallList[t],e.wallList[i]]}return e.createExitCells(s),e}createExitCells(t){const e=t.nextIntRange(0,3);let s=0,i=0;switch(e){case l.Top:s=t.nextIntRange(0,this.width-1),i=0;break;case l.Right:i=t.nextIntRange(0,this.height-1),s=this.width-1;break;case l.Bottom:s=t.nextIntRange(0,this.width-1),i=this.height-1;break;case l.Left:i=t.nextIntRange(0,this.height-1),s=0}switch(this.startCell=this.getCell(s,i),e){case l.Top:s=t.nextIntRange(0,this.width-1),i=this.height-1;break;case l.Right:i=t.nextIntRange(0,this.height-1),s=0;break;case l.Bottom:s=t.nextIntRange(0,this.width-1),i=0;break;case l.Left:i=t.nextIntRange(0,this.height-1),s=this.width-1}this.endCell=this.getCell(s,i)}}var A=Object.defineProperty,x=(t,e,s)=>((t,e,s)=>e in t?A(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s)(t,"symbol"!=typeof e?e+"":e,s);class O{constructor(t){this.maze=t,x(this,"openSet",[]),x(this,"closedSet",new Set),x(this,"startCell"),x(this,"endCell"),x(this,"current",null),x(this,"solutionFound",!1),x(this,"currentPath",[]),this.startCell=t.getStartCell(),this.endCell=t.getEndCell(),this.initialize()}initialize(){const t={cell:this.startCell,parent:null,g:0,h:this.heuristic(this.startCell),f:this.heuristic(this.startCell)};this.openSet=[t],this.closedSet.clear(),this.current=null,this.solutionFound=!1,this.currentPath=[this.startCell.position]}heuristic(t){return Math.abs(t.position.x-this.endCell.position.x)+Math.abs(t.position.y-this.endCell.position.y)}getNeighbors(t){const e=[],{cell:s}=t;for(let i=0;i<4;i++)if(!s.hasWall(i)){const t=s.getNeighborPosition(i),l=this.maze.getCell(t.x,t.y);l&&!this.closedSet.has(l)&&e.push(l)}return e}updateCurrentPath(){this.currentPath=[];let t=this.current;for(;t;)this.currentPath.unshift(t.cell.position),t=t.parent}getCurrentPath(){return this.currentPath}getOpenSet(){return this.openSet.map((t=>t.cell.position))}getClosedSet(){return Array.from(this.closedSet).map((t=>t.position))}iterate(){if(this.solutionFound)return!0;if(0===this.openSet.length)throw new I("No solution exists for this maze");if(this.current=this.openSet.reduce(((t,e)=>e.f<t.f?e:t),this.openSet[0]),this.openSet=this.openSet.filter((t=>t!==this.current)),this.closedSet.add(this.current.cell),this.updateCurrentPath(),this.current.cell===this.endCell)return this.solutionFound=!0,!0;for(const t of this.getNeighbors(this.current)){const e=this.current.g+1,s=this.heuristic(t),i=e+s,l=this.openSet.find((e=>e.cell===t));if(!l||e<l.g){const r={cell:t,parent:this.current,g:e,h:s,f:i};l?Object.assign(l,r):this.openSet.push(r)}}return!1}getSolution(){if(!this.solutionFound||!this.current||this.current.cell!==this.endCell)throw new I("No solution has been found yet");return{path:this.currentPath,start:this.startCell.position,end:this.endCell.position}}}var L=Object.defineProperty,P=(t,e,s)=>((t,e,s)=>e in t?L(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s)(t,"symbol"!=typeof e?e+"":e,s);new class{constructor(){P(this,"maze",null),P(this,"solver",null),P(this,"isGenerating",!1),this.setupMessageHandler()}setupMessageHandler(){self.onmessage=t=>{try{const{type:e,payload:s}=t.data;switch(e){case"generate":this.handleGenerate(s);break;case"iterate":this.handleIterate();break;case"solve":this.handleSolve();break;case"iterateSolution":this.handleIterateSolution();break;default:this.sendError(`Unknown message type: ${e}`)}}catch(e){this.sendError(e instanceof Error?e.message:"Unknown error")}}}serializeMaze(t){return{_cells:t.cells.map((t=>({position:{x:t.position.x,y:t.position.y},walls:Array.from(t.walls)}))),startCell:t.getStartCell()?{position:{x:t.getStartCell().position.x,y:t.getStartCell().position.y}}:void 0,endCell:t.getEndCell()?{position:{x:t.getEndCell().position.x,y:t.getEndCell().position.y}}:void 0}}handleGenerate(t){try{this.solver=null,this.isGenerating=!0,this.maze=N.generate(t);const e=this.serializeMaze(this.maze);this.sendProgress("generate",{done:!1,currentState:e})}catch(e){this.sendError(e instanceof Error?e.message:"Failed to generate maze")}}handleIterate(){if(this.maze)try{const t=this.maze.iterate(),e=this.serializeMaze(this.maze);this.sendProgress("iterate",{done:t,currentState:e}),t&&(this.isGenerating=!1,this.sendComplete("generate",{maze:e}))}catch(t){this.sendError(t instanceof Error?t.message:"Failed to iterate maze")}else this.sendError("Maze not generated")}handleSolve(){if(this.maze)if(this.isGenerating)this.sendError("Maze generation not complete");else try{this.solver=new O(this.maze);const t=this.solver.getCurrentPath(),e=this.solver.getOpenSet(),s=this.solver.getClosedSet();this.sendProgress("solve",{done:!1,currentPath:t,openSet:e,closedSet:s})}catch(t){this.sendError(t instanceof Error?t.message:"Failed to initialize solver")}else this.sendError("Maze not generated")}handleIterateSolution(){if(this.solver)try{const e=this.solver.iterate(),s=this.solver.getCurrentPath(),i=this.solver.getOpenSet(),l=this.solver.getClosedSet();if(this.sendProgress("iterateSolution",{done:e,currentPath:s,openSet:i,closedSet:l}),e)try{const t=this.solver.getSolution();this.sendComplete("solve",{solution:t}),this.solver=null}catch(t){this.sendError(t instanceof Error?t.message:"Failed to get solution")}}catch(t){this.sendError(t instanceof Error?t.message:"Failed to iterate solution")}else this.sendError("Solver not initialized")}sendProgress(t,e){self.postMessage({type:"progress",payload:{type:t,...e}})}sendComplete(t,e){self.postMessage({type:"complete",payload:{type:t,...e}})}sendError(t){self.postMessage({type:"error",payload:{message:t}})}};
//# sourceMappingURL=maze-worker-D7H0vNhN.js.map
