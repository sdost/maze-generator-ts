{"version":3,"file":"maze-worker-BDO96S6j.js","sources":["../src/objects/base-maze-cell.ts","../src/objects/square-maze-cell.ts","../src/objects/maze-wall.ts","../src/data-structures/disjoint-set.ts","../src/helpers/pseudo-random.ts","../src/errors/maze-errors.ts","../src/utils/config-validator.ts","../src/objects/square-maze-grid.ts","../src/objects/maze-solver.ts","../src/workers/maze-worker.ts"],"sourcesContent":["import { Position, MazeCell } from '../types/maze';\n\nexport abstract class BaseMazeCell implements MazeCell {\n  private readonly _walls: boolean[];\n  private _visited: boolean = false;\n\n  constructor(\n    private readonly _position: Position,\n    wallCount: number\n  ) {\n    this._walls = new Array(wallCount).fill(true);\n  }\n\n  public get position(): Position {\n    return this._position;\n  }\n\n  public get walls(): ReadonlyArray<boolean> {\n    return this._walls;\n  }\n\n  public get visited(): boolean {\n    return this._visited;\n  }\n\n  public set visited(value: boolean) {\n    this._visited = value;\n  }\n\n  public removeWall(index: number): void {\n    if (index >= 0 && index < this._walls.length) {\n      this._walls[index] = false;\n    }\n  }\n\n  public hasWall(index: number): boolean {\n    return index >= 0 && index < this._walls.length ? this._walls[index] : false;\n  }\n\n  public equals(other: BaseMazeCell): boolean {\n    return this._position.x === other._position.x && this._position.y === other._position.y;\n  }\n\n  public toString(): string {\n    return `Cell(${this._position.x}, ${this._position.y})`;\n  }\n}\n","import { Position } from '../types/maze';\nimport { BaseMazeCell } from './base-maze-cell';\n\nexport enum SquareWall {\n  Top = 0,\n  Right = 1,\n  Bottom = 2,\n  Left = 3,\n}\n\nexport class SquareMazeCell extends BaseMazeCell {\n  private static readonly WALL_COUNT = 4;\n\n  constructor(position: Position) {\n    super(position, SquareMazeCell.WALL_COUNT);\n  }\n\n  public removeWall(wall: SquareWall): void {\n    super.removeWall(wall);\n  }\n\n  public hasWall(wall: SquareWall): boolean {\n    return super.hasWall(wall);\n  }\n\n  public getNeighborPosition(wall: SquareWall): Position {\n    const { x, y } = this.position;\n    switch (wall) {\n      case SquareWall.Top:\n        return { x, y: y - 1 };\n      case SquareWall.Right:\n        return { x: x + 1, y };\n      case SquareWall.Bottom:\n        return { x, y: y + 1 };\n      case SquareWall.Left:\n        return { x: x - 1, y };\n      default:\n        throw new Error(`Invalid wall direction: ${wall}`);\n    }\n  }\n\n  public static getOppositeWall(wall: SquareWall): SquareWall {\n    switch (wall) {\n      case SquareWall.Top:\n        return SquareWall.Bottom;\n      case SquareWall.Right:\n        return SquareWall.Left;\n      case SquareWall.Bottom:\n        return SquareWall.Top;\n      case SquareWall.Left:\n        return SquareWall.Right;\n      default:\n        throw new Error(`Invalid wall direction: ${wall}`);\n    }\n  }\n}\n","import { SquareMazeCell } from './square-maze-cell';\n\ninterface MutableMazeWall extends MazeWall {\n  cellA: SquareMazeCell;\n  cellB: SquareMazeCell;\n}\n\nexport class MazeWall {\n  private static readonly wallPool: MazeWall[] = [];\n  private static readonly MAX_POOL_SIZE = 10000;\n\n  private constructor(\n    public readonly cellA: SquareMazeCell,\n    public readonly cellB: SquareMazeCell\n  ) {}\n\n  public static create(cellA: SquareMazeCell, cellB: SquareMazeCell): MazeWall {\n    if (this.wallPool.length > 0) {\n      const wall = this.wallPool.pop()! as MutableMazeWall;\n      wall.cellA = cellA;\n      wall.cellB = cellB;\n      return wall;\n    }\n    return new MazeWall(cellA, cellB);\n  }\n\n  public static release(wall: MazeWall): void {\n    if (this.wallPool.length < this.MAX_POOL_SIZE) {\n      this.wallPool.push(wall);\n    }\n  }\n\n  public equals(other: MazeWall): boolean {\n    return (\n      (this.cellA === other.cellA && this.cellB === other.cellB) ||\n      (this.cellA === other.cellB && this.cellB === other.cellA)\n    );\n  }\n\n  public toString(): string {\n    return `Wall(${this.cellA.toString()} - ${this.cellB.toString()})`;\n  }\n}\n","export class DisjointSet {\n  private parent: number[];\n  private rank: number[];\n\n  constructor(size: number) {\n    this.parent = Array.from({ length: size }, (_, i) => i);\n    this.rank = new Array(size).fill(0);\n  }\n\n  public createSet(x: number): void {\n    this.parent[x] = x;\n    this.rank[x] = 0;\n  }\n\n  public findSet(x: number): number {\n    if (x < 0 || x >= this.parent.length) {\n      throw new Error('Element not found in any set');\n    }\n\n    if (this.parent[x] !== x) {\n      this.parent[x] = this.findSet(this.parent[x]);\n    }\n\n    return this.parent[x];\n  }\n\n  public mergeSet(x: number, y: number): void {\n    const rootX = this.findSet(x);\n    const rootY = this.findSet(y);\n\n    if (rootX === rootY) {\n      return;\n    }\n\n    const rankX = this.rank[rootX];\n    const rankY = this.rank[rootY];\n\n    if (rankX < rankY) {\n      this.parent[rootX] = rootY;\n    } else if (rankX > rankY) {\n      this.parent[rootY] = rootX;\n    } else {\n      this.parent[rootY] = rootX;\n      this.rank[rootX] = rankX + 1;\n    }\n  }\n}\n","export class PseudoRandom {\n  private static readonly MULTIPLIER = 1664525;\n  private static readonly INCREMENT = 1013904223;\n  private static readonly MODULUS = 4294967296; // 2^32\n\n  private seed: number;\n\n  constructor(seed: number = Date.now()) {\n    this.seed = seed;\n  }\n\n  public nextInt(): number {\n    this.seed =\n      (this.seed * PseudoRandom.MULTIPLIER + PseudoRandom.INCREMENT) % PseudoRandom.MODULUS;\n    return this.seed;\n  }\n\n  public nextIntRange(min: number, max: number): number {\n    const range = max - min + 1;\n    const maxValue = PseudoRandom.MODULUS - (PseudoRandom.MODULUS % range);\n    let value: number;\n    do {\n      value = this.nextInt();\n    } while (value >= maxValue);\n    return min + (value % range);\n  }\n\n  public nextDouble(): number {\n    return this.nextInt() / PseudoRandom.MODULUS;\n  }\n\n  public nextDoubleRange(min: number, max: number): number {\n    return min + this.nextDouble() * (max - min);\n  }\n}\n","export class MazeError extends Error {\n  constructor(\n    message: string,\n    public readonly code: string\n  ) {\n    super(message);\n    this.name = 'MazeError';\n  }\n}\n\nexport class MazeGenerationError extends MazeError {\n  constructor(message: string) {\n    super(message, 'MAZE_GENERATION_ERROR');\n    this.name = 'MazeGenerationError';\n  }\n}\n\nexport class MazeSolvingError extends MazeError {\n  constructor(message: string) {\n    super(message, 'MAZE_SOLVING_ERROR');\n    this.name = 'MazeSolvingError';\n  }\n}\n\nexport class MazeRenderingError extends MazeError {\n  constructor(message: string) {\n    super(message, 'MAZE_RENDERING_ERROR');\n    this.name = 'MazeRenderingError';\n  }\n}\n\nexport class InvalidConfigError extends MazeError {\n  constructor(message: string) {\n    super(message, 'INVALID_CONFIG_ERROR');\n    this.name = 'InvalidConfigError';\n  }\n}\n","import { MazeConfig } from '../types/maze';\nimport { InvalidConfigError } from '../errors/maze-errors';\n\nexport class ConfigValidator {\n  private static readonly MIN_DIMENSION = 2;\n  private static readonly MAX_DIMENSION = 1000;\n  private static readonly MIN_CELL_SIZE = 4;\n  private static readonly MAX_CELL_SIZE = 100;\n  private static readonly MIN_ANIMATION_SPEED = 1;\n  private static readonly MAX_ANIMATION_SPEED = 1000;\n\n  public static validate(config: MazeConfig): void {\n    this.validateDimensions(config);\n    this.validateCellSize(config);\n    this.validateAnimationSpeed(config);\n  }\n\n  private static validateDimensions(config: MazeConfig): void {\n    if (config.width < this.MIN_DIMENSION || config.width > this.MAX_DIMENSION) {\n      throw new InvalidConfigError(\n        `Width must be between ${this.MIN_DIMENSION} and ${this.MAX_DIMENSION}`\n      );\n    }\n\n    if (config.height < this.MIN_DIMENSION || config.height > this.MAX_DIMENSION) {\n      throw new InvalidConfigError(\n        `Height must be between ${this.MIN_DIMENSION} and ${this.MAX_DIMENSION}`\n      );\n    }\n  }\n\n  private static validateCellSize(config: MazeConfig): void {\n    if (config.cellSize < this.MIN_CELL_SIZE || config.cellSize > this.MAX_CELL_SIZE) {\n      throw new InvalidConfigError(\n        `Cell size must be between ${this.MIN_CELL_SIZE} and ${this.MAX_CELL_SIZE}`\n      );\n    }\n  }\n\n  private static validateAnimationSpeed(config: MazeConfig): void {\n    if (\n      config.animationSpeed < this.MIN_ANIMATION_SPEED ||\n      config.animationSpeed > this.MAX_ANIMATION_SPEED\n    ) {\n      throw new InvalidConfigError(\n        `Animation speed must be between ${this.MIN_ANIMATION_SPEED} and ${this.MAX_ANIMATION_SPEED}`\n      );\n    }\n  }\n}\n","import { MazeGrid } from '../types/maze';\nimport { SquareMazeCell, SquareWall } from './square-maze-cell';\nimport { MazeWall } from './maze-wall';\nimport { DisjointSet } from '../data-structures/disjoint-set';\nimport { PseudoRandom } from '../helpers/pseudo-random';\nimport { ConfigValidator } from '../utils/config-validator';\nimport { MazeConfig } from '../types/maze';\nimport { MazeGenerationError } from '../errors/maze-errors';\n\nexport class SquareMazeGrid implements MazeGrid {\n  private readonly _cells: SquareMazeCell[];\n  private readonly wallList: MazeWall[];\n  private readonly sets: DisjointSet;\n  private startCell: SquareMazeCell | null = null;\n  private endCell: SquareMazeCell | null = null;\n\n  constructor(config: MazeConfig) {\n    ConfigValidator.validate(config);\n    this._cells = new Array<SquareMazeCell>(config.width * config.height);\n    this.wallList = [];\n    this.sets = new DisjointSet(config.width * config.height);\n    this.initializeGrid(config);\n  }\n\n  public get cells(): ReadonlyArray<SquareMazeCell> {\n    return this._cells;\n  }\n\n  public get width(): number {\n    return this._cells.length > 0 ? Math.sqrt(this._cells.length) : 0;\n  }\n\n  public get height(): number {\n    return this.width;\n  }\n\n  public getCell(x: number, y: number): SquareMazeCell | null {\n    if (x < 0 || x >= this.width || y < 0 || y >= this.height) {\n      return null;\n    }\n    return this._cells[x + y * this.width];\n  }\n\n  public getStartCell(): SquareMazeCell {\n    if (!this.startCell) {\n      throw new MazeGenerationError('Start cell not set');\n    }\n    return this.startCell;\n  }\n\n  public getEndCell(): SquareMazeCell {\n    if (!this.endCell) {\n      throw new MazeGenerationError('End cell not set');\n    }\n    return this.endCell;\n  }\n\n  public setStartCell(cell: SquareMazeCell): void {\n    this.startCell = cell;\n  }\n\n  public setEndCell(cell: SquareMazeCell): void {\n    this.endCell = cell;\n  }\n\n  private initializeGrid(config: MazeConfig): void {\n    // Initialize cells\n    for (let y = 0; y < config.height; y++) {\n      for (let x = 0; x < config.width; x++) {\n        const cell = new SquareMazeCell({ x, y });\n        this._cells[x + y * config.width] = cell;\n        this.sets.createSet(x + y * config.width);\n      }\n    }\n\n    // Initialize walls\n    for (let y = 0; y < config.height; y++) {\n      for (let x = 0; x < config.width; x++) {\n        const cell = this.getCell(x, y)!;\n\n        // Add walls to neighbors\n        if (x < config.width - 1) {\n          const rightCell = this.getCell(x + 1, y)!;\n          this.addWall(cell, rightCell);\n        }\n        if (y < config.height - 1) {\n          const bottomCell = this.getCell(x, y + 1)!;\n          this.addWall(cell, bottomCell);\n        }\n      }\n    }\n  }\n\n  private addWall(cellA: SquareMazeCell, cellB: SquareMazeCell): void {\n    const wall = MazeWall.create(cellA, cellB);\n    if (!this.wallList.some((w) => w.equals(wall))) {\n      this.wallList.push(wall);\n    } else {\n      MazeWall.release(wall);\n    }\n  }\n\n  public iterate(): boolean {\n    if (this.wallList.length === 0) {\n      return true;\n    }\n\n    const wall = this.wallList.pop()!;\n    const cellAIndex = wall.cellA.position.x + wall.cellA.position.y * this.width;\n    const cellBIndex = wall.cellB.position.x + wall.cellB.position.y * this.width;\n    if (this.sets.findSet(cellAIndex) !== this.sets.findSet(cellBIndex)) {\n      this.sets.mergeSet(cellAIndex, cellBIndex);\n      this.removeWallsBetween(wall.cellA, wall.cellB);\n    }\n\n    MazeWall.release(wall);\n    return false;\n  }\n\n  private removeWallsBetween(cellA: SquareMazeCell, cellB: SquareMazeCell): void {\n    const { x: x1, y: y1 } = cellA.position;\n    const { x: x2, y: y2 } = cellB.position;\n\n    if (x1 === x2) {\n      if (y1 < y2) {\n        cellA.removeWall(SquareWall.Bottom);\n        cellB.removeWall(SquareWall.Top);\n      } else {\n        cellA.removeWall(SquareWall.Top);\n        cellB.removeWall(SquareWall.Bottom);\n      }\n    } else {\n      if (x1 < x2) {\n        cellA.removeWall(SquareWall.Right);\n        cellB.removeWall(SquareWall.Left);\n      } else {\n        cellA.removeWall(SquareWall.Left);\n        cellB.removeWall(SquareWall.Right);\n      }\n    }\n  }\n\n  public static generate(config: MazeConfig): SquareMazeGrid {\n    const grid = new SquareMazeGrid(config);\n    const prng = new PseudoRandom(config.seed || Date.now());\n\n    // Shuffle walls using Fisher-Yates algorithm with seeded random\n    for (let i = grid.wallList.length - 1; i > 0; i--) {\n      const j = prng.nextIntRange(0, i);\n      [grid.wallList[i], grid.wallList[j]] = [grid.wallList[j], grid.wallList[i]];\n    }\n\n    // Create exit cells immediately\n    grid.createExitCells(prng);\n    return grid;\n  }\n\n  private createExitCells(prng: PseudoRandom): void {\n    const outerWall: SquareWall = prng.nextIntRange(0, 3);\n    let xPos = 0;\n    let yPos = 0;\n\n    // Set start cell\n    switch (outerWall) {\n      case SquareWall.Top:\n        xPos = prng.nextIntRange(0, this.width - 1);\n        yPos = 0;\n        break;\n      case SquareWall.Right:\n        yPos = prng.nextIntRange(0, this.height - 1);\n        xPos = this.width - 1;\n        break;\n      case SquareWall.Bottom:\n        xPos = prng.nextIntRange(0, this.width - 1);\n        yPos = this.height - 1;\n        break;\n      case SquareWall.Left:\n        yPos = prng.nextIntRange(0, this.height - 1);\n        xPos = 0;\n        break;\n    }\n\n    this.startCell = this.getCell(xPos, yPos);\n\n    // Set end cell on opposite wall\n    switch (outerWall) {\n      case SquareWall.Top:\n        xPos = prng.nextIntRange(0, this.width - 1);\n        yPos = this.height - 1;\n        break;\n      case SquareWall.Right:\n        yPos = prng.nextIntRange(0, this.height - 1);\n        xPos = 0;\n        break;\n      case SquareWall.Bottom:\n        xPos = prng.nextIntRange(0, this.width - 1);\n        yPos = 0;\n        break;\n      case SquareWall.Left:\n        yPos = prng.nextIntRange(0, this.height - 1);\n        xPos = this.width - 1;\n        break;\n    }\n\n    this.endCell = this.getCell(xPos, yPos);\n  }\n}\n","import { MazeGrid, Position, Solution } from '../types/maze';\nimport { SquareMazeCell } from './square-maze-cell';\nimport { MazeSolvingError } from '../errors/maze-errors';\n\ninterface Node {\n  cell: SquareMazeCell;\n  parent: Node | null;\n  g: number; // Cost from start to current\n  h: number; // Heuristic (estimated cost from current to end)\n  f: number; // Total cost (g + h)\n}\n\nexport class MazeSolver {\n  private openSet: Node[] = [];\n  private closedSet: Set<SquareMazeCell> = new Set();\n  private startCell: SquareMazeCell;\n  private endCell: SquareMazeCell;\n  private current: Node | null = null;\n  private solutionFound: boolean = false;\n  private currentPath: Position[] = [];\n\n  constructor(private maze: MazeGrid) {\n    this.startCell = maze.getStartCell() as SquareMazeCell;\n    this.endCell = maze.getEndCell() as SquareMazeCell;\n    this.initialize();\n  }\n\n  private initialize(): void {\n    // Create initial node for start cell\n    const startNode: Node = {\n      cell: this.startCell,\n      parent: null,\n      g: 0,\n      h: this.heuristic(this.startCell),\n      f: this.heuristic(this.startCell),\n    };\n\n    this.openSet = [startNode];\n    this.closedSet.clear();\n    this.current = null;\n    this.solutionFound = false;\n    this.currentPath = [this.startCell.position];\n  }\n\n  private heuristic(cell: SquareMazeCell): number {\n    // Manhattan distance to end cell\n    return (\n      Math.abs(cell.position.x - this.endCell.position.x) +\n      Math.abs(cell.position.y - this.endCell.position.y)\n    );\n  }\n\n  private getNeighbors(node: Node): SquareMazeCell[] {\n    const neighbors: SquareMazeCell[] = [];\n    const { cell } = node;\n\n    // Check all four directions\n    for (let wall = 0; wall < 4; wall++) {\n      // If there's no wall in this direction, we can move there\n      if (!cell.hasWall(wall)) {\n        const neighborPos = cell.getNeighborPosition(wall);\n        const neighbor = this.maze.getCell(neighborPos.x, neighborPos.y);\n\n        // Only add valid neighbors that haven't been visited\n        if (neighbor && !this.closedSet.has(neighbor as SquareMazeCell)) {\n          neighbors.push(neighbor as SquareMazeCell);\n        }\n      }\n    }\n\n    return neighbors;\n  }\n\n  private updateCurrentPath(): void {\n    this.currentPath = [];\n    let node: Node | null = this.current;\n    while (node) {\n      this.currentPath.unshift(node.cell.position);\n      node = node.parent;\n    }\n  }\n\n  public getCurrentPath(): Position[] {\n    return this.currentPath;\n  }\n\n  public getOpenSet(): Position[] {\n    return this.openSet.map((node) => node.cell.position);\n  }\n\n  public getClosedSet(): Position[] {\n    return Array.from(this.closedSet).map((cell) => cell.position);\n  }\n\n  public iterate(): boolean {\n    // If we've already found a solution, return true\n    if (this.solutionFound) {\n      return true;\n    }\n\n    // If there are no more nodes to explore, no solution exists\n    if (this.openSet.length === 0) {\n      throw new MazeSolvingError('No solution exists for this maze');\n    }\n\n    // Get node with lowest f score\n    this.current = this.openSet.reduce(\n      (min, node) => (node.f < min.f ? node : min),\n      this.openSet[0]\n    );\n\n    // Remove current from open set\n    this.openSet = this.openSet.filter((node) => node !== this.current);\n\n    // Add current to closed set\n    this.closedSet.add(this.current.cell);\n\n    // Update current path for animation\n    this.updateCurrentPath();\n\n    // Check if we reached the end\n    if (this.current.cell === this.endCell) {\n      this.solutionFound = true;\n      return true;\n    }\n\n    // Process neighbors\n    for (const neighbor of this.getNeighbors(this.current)) {\n      const gScore = this.current.g + 1;\n      const hScore = this.heuristic(neighbor);\n      const fScore = gScore + hScore;\n\n      // Check if this path to neighbor is better than previous ones\n      const existingNode = this.openSet.find((n) => n.cell === neighbor);\n      if (!existingNode || gScore < existingNode.g) {\n        const newNode: Node = {\n          cell: neighbor,\n          parent: this.current,\n          g: gScore,\n          h: hScore,\n          f: fScore,\n        };\n\n        if (!existingNode) {\n          this.openSet.push(newNode);\n        } else {\n          Object.assign(existingNode, newNode);\n        }\n      }\n    }\n\n    return false;\n  }\n\n  public getSolution(): Solution {\n    if (!this.solutionFound || !this.current || this.current.cell !== this.endCell) {\n      throw new MazeSolvingError('No solution has been found yet');\n    }\n\n    return {\n      path: this.currentPath,\n      start: this.startCell.position,\n      end: this.endCell.position,\n    };\n  }\n}\n","import { MazeConfig, Solution, Position } from '../types/maze';\nimport { SquareMazeGrid } from '../objects/square-maze-grid';\nimport { MazeSolver } from '../objects/maze-solver';\n\ninterface WorkerMessage {\n  type: 'generate' | 'iterate' | 'solve' | 'iterateSolution';\n  payload?: MazeConfig;\n}\n\ninterface WorkerResponse {\n  type: 'progress' | 'complete' | 'error';\n  payload: {\n    type?: string;\n    done?: boolean;\n    maze?: {\n      _cells: Array<{\n        position: Position;\n        walls: boolean[];\n      }>;\n      startCell?: { position: Position };\n      endCell?: { position: Position };\n    };\n    solution?: Solution;\n    currentPath?: Position[];\n    openSet?: Position[];\n    closedSet?: Position[];\n    message?: string;\n    currentState?: {\n      _cells: Array<{\n        position: Position;\n        walls: boolean[];\n      }>;\n      startCell?: { position: Position };\n      endCell?: { position: Position };\n    };\n  };\n}\n\nclass MazeWorker {\n  private maze: SquareMazeGrid | null = null;\n  private solver: MazeSolver | null = null;\n  private isGenerating: boolean = false;\n\n  constructor() {\n    this.setupMessageHandler();\n  }\n\n  private setupMessageHandler(): void {\n    self.onmessage = (event: MessageEvent<WorkerMessage>): void => {\n      try {\n        const { type, payload } = event.data;\n        switch (type) {\n          case 'generate':\n            this.handleGenerate(payload as MazeConfig);\n            break;\n          case 'iterate':\n            this.handleIterate();\n            break;\n          case 'solve':\n            this.handleSolve();\n            break;\n          case 'iterateSolution':\n            this.handleIterateSolution();\n            break;\n          default:\n            this.sendError(`Unknown message type: ${type}`);\n        }\n      } catch (error) {\n        console.error('Worker error:', error);\n        this.sendError(error instanceof Error ? error.message : 'Unknown error');\n      }\n    };\n  }\n\n  private serializeMaze(maze: SquareMazeGrid): WorkerResponse['payload']['maze'] {\n    return {\n      _cells: maze.cells.map((cell) => ({\n        position: { x: cell.position.x, y: cell.position.y },\n        walls: Array.from(cell.walls),\n      })),\n      startCell: maze.getStartCell()\n        ? {\n            position: { x: maze.getStartCell().position.x, y: maze.getStartCell().position.y },\n          }\n        : undefined,\n      endCell: maze.getEndCell()\n        ? {\n            position: { x: maze.getEndCell().position.x, y: maze.getEndCell().position.y },\n          }\n        : undefined,\n    };\n  }\n\n  private handleGenerate(config: MazeConfig): void {\n    try {\n      this.solver = null;\n      this.isGenerating = true;\n      this.maze = SquareMazeGrid.generate(config);\n      const serializedMaze = this.serializeMaze(this.maze);\n      this.sendProgress('generate', {\n        done: false,\n        currentState: serializedMaze,\n      });\n    } catch (error) {\n      console.error('Error generating maze:', error);\n      this.sendError(error instanceof Error ? error.message : 'Failed to generate maze');\n    }\n  }\n\n  private handleIterate(): void {\n    if (!this.maze) {\n      this.sendError('Maze not generated');\n      return;\n    }\n\n    try {\n      const done = this.maze.iterate();\n      const serializedMaze = this.serializeMaze(this.maze);\n      this.sendProgress('iterate', {\n        done,\n        currentState: serializedMaze,\n      });\n\n      if (done) {\n        this.isGenerating = false;\n        this.sendComplete('generate', { maze: serializedMaze });\n      }\n    } catch (error) {\n      console.error('Error during iteration:', error);\n      this.sendError(error instanceof Error ? error.message : 'Failed to iterate maze');\n    }\n  }\n\n  private handleSolve(): void {\n    if (!this.maze) {\n      this.sendError('Maze not generated');\n      return;\n    }\n    if (this.isGenerating) {\n      this.sendError('Maze generation not complete');\n      return;\n    }\n\n    try {\n      this.solver = new MazeSolver(this.maze);\n\n      // Send initial state\n      const currentPath = this.solver.getCurrentPath();\n      const openSet = this.solver.getOpenSet();\n      const closedSet = this.solver.getClosedSet();\n\n      this.sendProgress('solve', {\n        done: false,\n        currentPath,\n        openSet,\n        closedSet,\n      });\n    } catch (error) {\n      console.error('Error initializing solver:', error);\n      this.sendError(error instanceof Error ? error.message : 'Failed to initialize solver');\n    }\n  }\n\n  private handleIterateSolution(): void {\n    if (!this.solver) {\n      this.sendError('Solver not initialized');\n      return;\n    }\n\n    try {\n      const done = this.solver.iterate();\n\n      // Always send progress, even if done\n      const currentPath = this.solver.getCurrentPath();\n      const openSet = this.solver.getOpenSet();\n      const closedSet = this.solver.getClosedSet();\n\n      this.sendProgress('iterateSolution', {\n        done,\n        currentPath,\n        openSet,\n        closedSet,\n      });\n\n      if (done) {\n        try {\n          const solution = this.solver.getSolution();\n          this.sendComplete('solve', { solution });\n          this.solver = null;\n        } catch (error) {\n          console.error('Error getting solution:', error);\n          this.sendError(error instanceof Error ? error.message : 'Failed to get solution');\n        }\n      }\n    } catch (error) {\n      console.error('Error during solution iteration:', error);\n      this.sendError(error instanceof Error ? error.message : 'Failed to iterate solution');\n    }\n  }\n\n  private sendProgress(type: string, payload: WorkerResponse['payload']): void {\n    self.postMessage({\n      type: 'progress',\n      payload: { type, ...payload },\n    } as WorkerResponse);\n  }\n\n  private sendComplete(type: string, payload: WorkerResponse['payload']): void {\n    self.postMessage({\n      type: 'complete',\n      payload: { type, ...payload },\n    } as WorkerResponse);\n  }\n\n  private sendError(message: string): void {\n    console.error('Sending error:', message);\n    self.postMessage({\n      type: 'error',\n      payload: { message },\n    } as WorkerResponse);\n  }\n}\n\n// Initialize the worker\nnew MazeWorker();\n"],"names":["BaseMazeCell","constructor","_position","wallCount","this","__publicField","_walls","Array","fill","position","walls","visited","_visited","value","removeWall","index","length","hasWall","equals","other","x","y","toString","SquareWall","_SquareMazeCell","super","WALL_COUNT","wall","getNeighborPosition","Error","getOppositeWall","SquareMazeCell","_MazeWall","cellA","cellB","create","wallPool","pop","release","MAX_POOL_SIZE","push","MazeWall","DisjointSet","size","parent","from","_","i","rank","createSet","findSet","mergeSet","rootX","rootY","rankX","rankY","_PseudoRandom","seed","Date","now","nextInt","MULTIPLIER","INCREMENT","MODULUS","nextIntRange","min","max","range","maxValue","nextDouble","nextDoubleRange","PseudoRandom","MazeError","message","code","name","MazeGenerationError","MazeSolvingError","InvalidConfigError","ConfigValidator","validate","config","validateDimensions","validateCellSize","validateAnimationSpeed","width","MIN_DIMENSION","MAX_DIMENSION","height","cellSize","MIN_CELL_SIZE","MAX_CELL_SIZE","animationSpeed","MIN_ANIMATION_SPEED","MAX_ANIMATION_SPEED","SquareMazeGrid","_cells","wallList","sets","initializeGrid","cells","Math","sqrt","getCell","getStartCell","startCell","getEndCell","endCell","setStartCell","cell","setEndCell","rightCell","addWall","bottomCell","some","w","iterate","cellAIndex","cellBIndex","removeWallsBetween","x1","y1","x2","y2","Bottom","Top","Right","Left","generate","grid","prng","j","createExitCells","outerWall","xPos","yPos","MazeSolver","maze","Set","initialize","startNode","g","h","heuristic","f","openSet","closedSet","clear","current","solutionFound","currentPath","abs","getNeighbors","node","neighbors","neighborPos","neighbor","has","updateCurrentPath","unshift","getCurrentPath","getOpenSet","map","getClosedSet","reduce","filter","add","gScore","hScore","fScore","existingNode","find","n","newNode","Object","assign","getSolution","path","start","end","setupMessageHandler","self","onmessage","event","type","payload","data","handleGenerate","handleIterate","handleSolve","handleIterateSolution","sendError","error","serializeMaze","solver","isGenerating","serializedMaze","sendProgress","done","currentState","sendComplete","solution","postMessage"],"mappings":"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"}