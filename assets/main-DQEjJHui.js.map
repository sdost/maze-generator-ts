{"version":3,"file":"main-DQEjJHui.js","sources":["../../src/objects/base-maze-cell.ts","../../src/objects/square-maze-cell.ts","../../src/objects/maze-wall.ts","../../src/data-structures/disjoint-set.ts","../../src/helpers/pseudo-random.ts","../../src/errors/maze-errors.ts","../../src/utils/config-validator.ts","../../src/objects/square-maze-grid.ts","../../src/objects/maze-solver.ts","../../src/objects/maze-renderer.ts","../../src/maze-worker.ts","../../src/main.ts"],"sourcesContent":["import { Position, MazeCell } from '../types/maze';\n\nexport abstract class BaseMazeCell implements MazeCell {\n  private readonly _walls: boolean[];\n  private _visited: boolean = false;\n\n  constructor(\n    private readonly _position: Position,\n    wallCount: number\n  ) {\n    this._walls = new Array(wallCount).fill(true);\n  }\n\n  public get position(): Position {\n    return this._position;\n  }\n\n  public get walls(): ReadonlyArray<boolean> {\n    return this._walls;\n  }\n\n  public get visited(): boolean {\n    return this._visited;\n  }\n\n  public set visited(value: boolean) {\n    this._visited = value;\n  }\n\n  public removeWall(index: number): void {\n    if (index >= 0 && index < this._walls.length) {\n      this._walls[index] = false;\n    }\n  }\n\n  public hasWall(index: number): boolean {\n    return index >= 0 && index < this._walls.length ? this._walls[index] : false;\n  }\n\n  public equals(other: BaseMazeCell): boolean {\n    return (\n      this._position.x === other._position.x && this._position.y === other._position.y\n    );\n  }\n\n  public toString(): string {\n    return `Cell(${this._position.x}, ${this._position.y})`;\n  }\n}","import { Position } from '../types/maze';\nimport { BaseMazeCell } from './base-maze-cell';\n\nexport enum SquareWall {\n  Top = 0,\n  Right = 1,\n  Bottom = 2,\n  Left = 3,\n}\n\nexport class SquareMazeCell extends BaseMazeCell {\n  private static readonly WALL_COUNT = 4;\n\n  constructor(position: Position) {\n    super(position, SquareMazeCell.WALL_COUNT);\n  }\n\n  public removeWall(wall: SquareWall): void {\n    super.removeWall(wall);\n  }\n\n  public hasWall(wall: SquareWall): boolean {\n    return super.hasWall(wall);\n  }\n\n  public getNeighborPosition(wall: SquareWall): Position {\n    const { x, y } = this.position;\n    switch (wall) {\n      case SquareWall.Top:\n        return { x, y: y - 1 };\n      case SquareWall.Right:\n        return { x: x + 1, y };\n      case SquareWall.Bottom:\n        return { x, y: y + 1 };\n      case SquareWall.Left:\n        return { x: x - 1, y };\n      default:\n        throw new Error(`Invalid wall direction: ${wall}`);\n    }\n  }\n\n  public static getOppositeWall(wall: SquareWall): SquareWall {\n    switch (wall) {\n      case SquareWall.Top:\n        return SquareWall.Bottom;\n      case SquareWall.Right:\n        return SquareWall.Left;\n      case SquareWall.Bottom:\n        return SquareWall.Top;\n      case SquareWall.Left:\n        return SquareWall.Right;\n      default:\n        throw new Error(`Invalid wall direction: ${wall}`);\n    }\n  }\n}","import { SquareMazeCell } from './square-maze-cell';\n\nexport class MazeWall {\n  private static readonly wallPool: MazeWall[] = [];\n  private static readonly MAX_POOL_SIZE = 10000;\n\n  private constructor(\n    public readonly cellA: SquareMazeCell,\n    public readonly cellB: SquareMazeCell\n  ) {}\n\n  public static create(cellA: SquareMazeCell, cellB: SquareMazeCell): MazeWall {\n    if (this.wallPool.length > 0) {\n      const wall = this.wallPool.pop()!;\n      (wall as any).cellA = cellA;\n      (wall as any).cellB = cellB;\n      return wall;\n    }\n    return new MazeWall(cellA, cellB);\n  }\n\n  public static release(wall: MazeWall): void {\n    if (this.wallPool.length < this.MAX_POOL_SIZE) {\n      this.wallPool.push(wall);\n    }\n  }\n\n  public equals(other: MazeWall): boolean {\n    return (\n      (this.cellA === other.cellA && this.cellB === other.cellB) ||\n      (this.cellA === other.cellB && this.cellB === other.cellA)\n    );\n  }\n\n  public toString(): string {\n    return `Wall(${this.cellA.toString()} - ${this.cellB.toString()})`;\n  }\n}","export class DisjointSet {\n  private parent: number[];\n  private rank: number[];\n\n  constructor(size: number) {\n    this.parent = Array.from({ length: size }, (_, i) => i);\n    this.rank = new Array(size).fill(0);\n  }\n\n  public createSet(x: number): void {\n    this.parent[x] = x;\n    this.rank[x] = 0;\n  }\n\n  public findSet(x: number): number {\n    if (x < 0 || x >= this.parent.length) {\n      throw new Error('Element not found in any set');\n    }\n\n    if (this.parent[x] !== x) {\n      this.parent[x] = this.findSet(this.parent[x]);\n    }\n\n    return this.parent[x];\n  }\n\n  public mergeSet(x: number, y: number): void {\n    const rootX = this.findSet(x);\n    const rootY = this.findSet(y);\n\n    if (rootX === rootY) {\n      return;\n    }\n\n    const rankX = this.rank[rootX];\n    const rankY = this.rank[rootY];\n\n    if (rankX < rankY) {\n      this.parent[rootX] = rootY;\n    } else if (rankX > rankY) {\n      this.parent[rootY] = rootX;\n    } else {\n      this.parent[rootY] = rootX;\n      this.rank[rootX] = rankX + 1;\n    }\n  }\n}","export class PseudoRandom {\n  private static readonly MULTIPLIER = 1664525;\n  private static readonly INCREMENT = 1013904223;\n  private static readonly MODULUS = 4294967296; // 2^32\n\n  private seed: number;\n\n  constructor(seed: number = Date.now()) {\n    this.seed = seed;\n  }\n\n  public nextInt(): number {\n    this.seed = (this.seed * PseudoRandom.MULTIPLIER + PseudoRandom.INCREMENT) % PseudoRandom.MODULUS;\n    return this.seed;\n  }\n\n  public nextIntRange(min: number, max: number): number {\n    return min + (this.nextInt() % (max - min + 1));\n  }\n\n  public nextDouble(): number {\n    return this.nextInt() / PseudoRandom.MODULUS;\n  }\n\n  public nextDoubleRange(min: number, max: number): number {\n    return min + (this.nextDouble() * (max - min));\n  }\n}","export class MazeError extends Error {\n  constructor(message: string, public readonly code: string) {\n    super(message);\n    this.name = 'MazeError';\n  }\n}\n\nexport class MazeGenerationError extends MazeError {\n  constructor(message: string) {\n    super(message, 'MAZE_GENERATION_ERROR');\n    this.name = 'MazeGenerationError';\n  }\n}\n\nexport class MazeSolvingError extends MazeError {\n  constructor(message: string) {\n    super(message, 'MAZE_SOLVING_ERROR');\n    this.name = 'MazeSolvingError';\n  }\n}\n\nexport class MazeRenderingError extends MazeError {\n  constructor(message: string) {\n    super(message, 'MAZE_RENDERING_ERROR');\n    this.name = 'MazeRenderingError';\n  }\n}\n\nexport class InvalidConfigError extends MazeError {\n  constructor(message: string) {\n    super(message, 'INVALID_CONFIG_ERROR');\n    this.name = 'InvalidConfigError';\n  }\n}","import { MazeConfig } from '../types/maze';\nimport { InvalidConfigError } from '../errors/maze-errors';\n\nexport class ConfigValidator {\n  private static readonly MIN_DIMENSION = 2;\n  private static readonly MAX_DIMENSION = 1000;\n  private static readonly MIN_CELL_SIZE = 4;\n  private static readonly MAX_CELL_SIZE = 100;\n  private static readonly MIN_ANIMATION_SPEED = 1;\n  private static readonly MAX_ANIMATION_SPEED = 1000;\n\n  public static validate(config: MazeConfig): void {\n    this.validateDimensions(config);\n    this.validateCellSize(config);\n    this.validateAnimationSpeed(config);\n  }\n\n  private static validateDimensions(config: MazeConfig): void {\n    if (config.width < this.MIN_DIMENSION || config.width > this.MAX_DIMENSION) {\n      throw new InvalidConfigError(\n        `Width must be between ${this.MIN_DIMENSION} and ${this.MAX_DIMENSION}`\n      );\n    }\n\n    if (config.height < this.MIN_DIMENSION || config.height > this.MAX_DIMENSION) {\n      throw new InvalidConfigError(\n        `Height must be between ${this.MIN_DIMENSION} and ${this.MAX_DIMENSION}`\n      );\n    }\n  }\n\n  private static validateCellSize(config: MazeConfig): void {\n    if (config.cellSize < this.MIN_CELL_SIZE || config.cellSize > this.MAX_CELL_SIZE) {\n      throw new InvalidConfigError(\n        `Cell size must be between ${this.MIN_CELL_SIZE} and ${this.MAX_CELL_SIZE}`\n      );\n    }\n  }\n\n  private static validateAnimationSpeed(config: MazeConfig): void {\n    if (\n      config.animationSpeed < this.MIN_ANIMATION_SPEED ||\n      config.animationSpeed > this.MAX_ANIMATION_SPEED\n    ) {\n      throw new InvalidConfigError(\n        `Animation speed must be between ${this.MIN_ANIMATION_SPEED} and ${this.MAX_ANIMATION_SPEED}`\n      );\n    }\n  }\n}","import { MazeGrid } from '../types/maze';\nimport { SquareMazeCell, SquareWall } from './square-maze-cell';\nimport { MazeWall } from './maze-wall';\nimport { DisjointSet } from '../data-structures/disjoint-set';\nimport { PseudoRandom } from '../helpers/pseudo-random';\nimport { ConfigValidator } from '../utils/config-validator';\nimport { MazeConfig } from '../types/maze';\nimport { MazeGenerationError } from '../errors/maze-errors';\n\nexport class SquareMazeGrid implements MazeGrid {\n  private readonly _cells: SquareMazeCell[];\n  private readonly wallList: MazeWall[];\n  private readonly sets: DisjointSet;\n  private startCell: SquareMazeCell | null = null;\n  private endCell: SquareMazeCell | null = null;\n\n  constructor(config: MazeConfig) {\n    ConfigValidator.validate(config);\n    this._cells = new Array<SquareMazeCell>(config.width * config.height);\n    this.wallList = [];\n    this.sets = new DisjointSet(config.width * config.height);\n    this.initializeGrid(config);\n  }\n\n  public get cells(): ReadonlyArray<SquareMazeCell> {\n    return this._cells;\n  }\n\n  public get width(): number {\n    return this._cells.length > 0 ? Math.sqrt(this._cells.length) : 0;\n  }\n\n  public get height(): number {\n    return this.width;\n  }\n\n  public getCell(x: number, y: number): SquareMazeCell | null {\n    if (x < 0 || x >= this.width || y < 0 || y >= this.height) {\n      return null;\n    }\n    return this._cells[x + y * this.width];\n  }\n\n  public getStartCell(): SquareMazeCell {\n    if (!this.startCell) {\n      throw new MazeGenerationError('Start cell not set');\n    }\n    return this.startCell;\n  }\n\n  public getEndCell(): SquareMazeCell {\n    if (!this.endCell) {\n      throw new MazeGenerationError('End cell not set');\n    }\n    return this.endCell;\n  }\n\n  private initializeGrid(config: MazeConfig): void {\n    // Initialize cells\n    for (let y = 0; y < config.height; y++) {\n      for (let x = 0; x < config.width; x++) {\n        const cell = new SquareMazeCell({ x, y });\n        this._cells[x + y * config.width] = cell;\n        this.sets.createSet(x + y * config.width);\n      }\n    }\n\n    // Initialize walls\n    for (const cell of this._cells) {\n      for (let wall = 0; wall < 4; wall++) {\n        const neighborPos = cell.getNeighborPosition(wall);\n        const neighbor = this.getCell(neighborPos.x, neighborPos.y);\n        if (neighbor) {\n          this.addWall(cell, neighbor);\n        }\n      }\n    }\n  }\n\n  private addWall(cellA: SquareMazeCell, cellB: SquareMazeCell): void {\n    const wall = MazeWall.create(cellA, cellB);\n    if (!this.wallList.some(w => w.equals(wall))) {\n      this.wallList.push(wall);\n    } else {\n      MazeWall.release(wall);\n    }\n  }\n\n  public iterate(): boolean {\n    if (this.wallList.length === 0) {\n      return true;\n    }\n\n    const wall = this.wallList.pop()!;\n    const cellAIndex = wall.cellA.position.x + wall.cellA.position.y * this.width;\n    const cellBIndex = wall.cellB.position.x + wall.cellB.position.y * this.width;\n    if (this.sets.findSet(cellAIndex) !== this.sets.findSet(cellBIndex)) {\n      this.sets.mergeSet(cellAIndex, cellBIndex);\n      this.removeWallsBetween(wall.cellA, wall.cellB);\n    }\n\n    MazeWall.release(wall);\n    return false;\n  }\n\n  private removeWallsBetween(cellA: SquareMazeCell, cellB: SquareMazeCell): void {\n    const { x: x1, y: y1 } = cellA.position;\n    const { x: x2, y: y2 } = cellB.position;\n\n    if (x1 === x2) {\n      if (y1 < y2) {\n        cellA.removeWall(SquareWall.Bottom);\n        cellB.removeWall(SquareWall.Top);\n      } else {\n        cellA.removeWall(SquareWall.Top);\n        cellB.removeWall(SquareWall.Bottom);\n      }\n    } else {\n      if (x1 < x2) {\n        cellA.removeWall(SquareWall.Right);\n        cellB.removeWall(SquareWall.Left);\n      } else {\n        cellA.removeWall(SquareWall.Left);\n        cellB.removeWall(SquareWall.Right);\n      }\n    }\n  }\n\n  public static generate(config: MazeConfig): SquareMazeGrid {\n    const grid = new SquareMazeGrid(config);\n    const prng = new PseudoRandom(config.seed || Date.now());\n\n    // Shuffle walls\n    for (let i = grid.wallList.length - 1; i > 0; i--) {\n      const j = prng.nextIntRange(0, i);\n      [grid.wallList[i], grid.wallList[j]] = [grid.wallList[j], grid.wallList[i]];\n    }\n\n    grid.createExitCells(prng);\n    return grid;\n  }\n\n  private createExitCells(prng: PseudoRandom): void {\n    let outerWall: SquareWall = prng.nextIntRange(0, 3);\n    let xPos = 0;\n    let yPos = 0;\n\n    // Set start cell\n    switch (outerWall) {\n      case SquareWall.Top:\n        xPos = prng.nextIntRange(0, this.width - 1);\n        yPos = 0;\n        break;\n      case SquareWall.Right:\n        yPos = prng.nextIntRange(0, this.height - 1);\n        xPos = this.width - 1;\n        break;\n      case SquareWall.Bottom:\n        xPos = prng.nextIntRange(0, this.width - 1);\n        yPos = this.height - 1;\n        break;\n      case SquareWall.Left:\n        yPos = prng.nextIntRange(0, this.height - 1);\n        xPos = 0;\n        break;\n    }\n\n    this.startCell = this.getCell(xPos, yPos);\n\n    // Set end cell on opposite wall\n    switch (outerWall) {\n      case SquareWall.Top:\n        xPos = prng.nextIntRange(0, this.width - 1);\n        yPos = this.height - 1;\n        break;\n      case SquareWall.Right:\n        yPos = prng.nextIntRange(0, this.height - 1);\n        xPos = 0;\n        break;\n      case SquareWall.Bottom:\n        xPos = prng.nextIntRange(0, this.width - 1);\n        yPos = 0;\n        break;\n      case SquareWall.Left:\n        yPos = prng.nextIntRange(0, this.height - 1);\n        xPos = this.width - 1;\n        break;\n    }\n\n    this.endCell = this.getCell(xPos, yPos);\n  }\n}","import { MazeGrid, Position, Solution } from '../types/maze';\nimport { SquareMazeCell } from './square-maze-cell';\nimport { MazeSolvingError } from '../errors/maze-errors';\n\ninterface Node {\n  cell: SquareMazeCell;\n  parent: Node | null;\n  g: number; // Cost from start to current\n  h: number; // Heuristic (estimated cost from current to end)\n  f: number; // Total cost (g + h)\n}\n\nexport class MazeSolver {\n  private openSet: Node[] = [];\n  private closedSet: Set<SquareMazeCell> = new Set();\n  private startCell: SquareMazeCell;\n  private endCell: SquareMazeCell;\n  private current: Node | null = null;\n  private solutionFound: boolean = false;\n  private currentPath: Position[] = [];\n\n  constructor(private maze: MazeGrid) {\n    this.startCell = maze.getStartCell() as SquareMazeCell;\n    this.endCell = maze.getEndCell() as SquareMazeCell;\n    this.initialize();\n  }\n\n  private initialize(): void {\n    const startNode: Node = {\n      cell: this.startCell,\n      parent: null,\n      g: 0,\n      h: this.heuristic(this.startCell),\n      f: this.heuristic(this.startCell)\n    };\n    this.openSet.push(startNode);\n    this.currentPath = [this.startCell.position];\n  }\n\n  private heuristic(cell: SquareMazeCell): number {\n    const { x: x1, y: y1 } = cell.position;\n    const { x: x2, y: y2 } = this.endCell.position;\n    return Math.abs(x1 - x2) + Math.abs(y1 - y2);\n  }\n\n  private getNeighbors(node: Node): SquareMazeCell[] {\n    const neighbors: SquareMazeCell[] = [];\n    const { cell } = node;\n\n    // Check all four directions\n    for (let wall = 0; wall < 4; wall++) {\n      // If there's no wall in this direction, we can move there\n      if (!cell.hasWall(wall)) {\n        const neighborPos = cell.getNeighborPosition(wall);\n        const neighbor = this.maze.getCell(neighborPos.x, neighborPos.y);\n\n        // Only add valid neighbors that haven't been visited\n        if (neighbor && !this.closedSet.has(neighbor as SquareMazeCell)) {\n          neighbors.push(neighbor as SquareMazeCell);\n        }\n      }\n    }\n\n    return neighbors;\n  }\n\n  public iterate(): boolean {\n    // If we've already found a solution, return true\n    if (this.solutionFound) {\n      return true;\n    }\n\n    // If there are no more nodes to explore, no solution exists\n    if (this.openSet.length === 0) {\n      throw new MazeSolvingError('No solution exists for this maze');\n    }\n\n    // Get node with lowest f score\n    this.current = this.openSet.reduce((min, node) =>\n      node.f < min.f ? node : min, this.openSet[0]);\n\n    // Remove current from open set\n    this.openSet = this.openSet.filter(node => node !== this.current);\n\n    // Add current to closed set\n    this.closedSet.add(this.current.cell);\n\n    // Update current path for animation\n    this.updateCurrentPath();\n\n    // Check if we reached the end\n    if (this.current.cell === this.endCell) {\n      this.solutionFound = true;\n      return true;\n    }\n\n    // Process neighbors\n    for (const neighbor of this.getNeighbors(this.current)) {\n      const gScore = this.current.g + 1;\n      const hScore = this.heuristic(neighbor);\n      const fScore = gScore + hScore;\n\n      // Check if this path to neighbor is better than previous ones\n      const existingNode = this.openSet.find(n => n.cell === neighbor);\n      if (!existingNode || gScore < existingNode.g) {\n        const newNode: Node = {\n          cell: neighbor,\n          parent: this.current,\n          g: gScore,\n          h: hScore,\n          f: fScore\n        };\n\n        if (!existingNode) {\n          this.openSet.push(newNode);\n        } else {\n          Object.assign(existingNode, newNode);\n        }\n      }\n    }\n\n    return false;\n  }\n\n  private updateCurrentPath(): void {\n    if (!this.current) return;\n\n    const path: Position[] = [];\n    let node: Node | null = this.current;\n\n    while (node) {\n      path.unshift(node.cell.position);\n      node = node.parent;\n    }\n\n    this.currentPath = path;\n  }\n\n  public getCurrentPath(): Position[] {\n    return this.currentPath;\n  }\n\n  public getOpenSet(): Position[] {\n    return this.openSet.map(node => node.cell.position);\n  }\n\n  public getClosedSet(): Position[] {\n    return Array.from(this.closedSet).map(cell => cell.position);\n  }\n\n  public getSolution(): Solution {\n    if (!this.solutionFound || !this.current || this.current.cell !== this.endCell) {\n      throw new MazeSolvingError('No solution has been found yet');\n    }\n\n    return {\n      path: this.currentPath,\n      start: this.startCell.position,\n      end: this.endCell.position\n    };\n  }\n}","import { MazeGrid, Solution } from '../types/maze';\nimport { Position } from '../types/maze';\n\nexport class MazeRenderer {\n  private ctx: CanvasRenderingContext2D;\n  private cellSize: number = 0;\n  private offsetX: number = 0;\n  private offsetY: number = 0;\n\n  constructor(private canvas: HTMLCanvasElement, private maze: MazeGrid) {\n    const context = canvas.getContext('2d');\n    if (!context) {\n      throw new Error('Could not get canvas context');\n    }\n    this.ctx = context;\n    this.calculateDimensions();\n  }\n\n  private calculateDimensions(): void {\n    const padding = 20;\n    this.cellSize = Math.min(\n      (this.canvas.width - padding * 2) / this.maze.width,\n      (this.canvas.height - padding * 2) / this.maze.height\n    );\n    this.offsetX = (this.canvas.width - this.maze.width * this.cellSize) / 2;\n    this.offsetY = (this.canvas.height - this.maze.height * this.cellSize) / 2;\n  }\n\n  public render(): void {\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    this.drawMaze();\n  }\n\n  public renderSolution(solution: Solution): void {\n    this.render();\n    this.drawPath(solution.path, '#ff0000', 3);\n  }\n\n  public renderSolvingProgress(\n    currentPath: Position[],\n    openSet: Position[],\n    closedSet: Position[]\n  ): void {\n    this.render();\n\n    // Draw closed set (visited cells)\n    this.drawCells(closedSet, '#cccccc', 0.5);\n\n    // Draw open set (frontier)\n    this.drawCells(openSet, '#90EE90', 0.5);\n\n    // Draw current path\n    this.drawPath(currentPath, '#ff0000', 2);\n  }\n\n  private drawMaze(): void {\n    // Draw background\n    this.ctx.fillStyle = '#ffffff';\n    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n\n    // Draw cells and walls\n    for (let y = 0; y < this.maze.height; y++) {\n      for (let x = 0; x < this.maze.width; x++) {\n        const cell = this.maze.getCell(x, y);\n        if (cell) {\n          this.drawCell(cell);\n        }\n      }\n    }\n\n    // Draw start and end cells\n    this.drawCell(this.maze.getStartCell(), '#00ff00');\n    this.drawCell(this.maze.getEndCell(), '#ff0000');\n  }\n\n  private drawCell(cell: any, color: string = '#000000'): void {\n    const { x, y } = cell.position;\n    const cellX = this.offsetX + x * this.cellSize;\n    const cellY = this.offsetY + y * this.cellSize;\n\n    // Draw cell walls\n    this.ctx.strokeStyle = color;\n    this.ctx.lineWidth = 2;\n\n    if (cell.hasWall(0)) { // Top\n      this.ctx.beginPath();\n      this.ctx.moveTo(cellX, cellY);\n      this.ctx.lineTo(cellX + this.cellSize, cellY);\n      this.ctx.stroke();\n    }\n    if (cell.hasWall(1)) { // Right\n      this.ctx.beginPath();\n      this.ctx.moveTo(cellX + this.cellSize, cellY);\n      this.ctx.lineTo(cellX + this.cellSize, cellY + this.cellSize);\n      this.ctx.stroke();\n    }\n    if (cell.hasWall(2)) { // Bottom\n      this.ctx.beginPath();\n      this.ctx.moveTo(cellX, cellY + this.cellSize);\n      this.ctx.lineTo(cellX + this.cellSize, cellY + this.cellSize);\n      this.ctx.stroke();\n    }\n    if (cell.hasWall(3)) { // Left\n      this.ctx.beginPath();\n      this.ctx.moveTo(cellX, cellY);\n      this.ctx.lineTo(cellX, cellY + this.cellSize);\n      this.ctx.stroke();\n    }\n  }\n\n  private drawPath(path: Position[], color: string, lineWidth: number): void {\n    if (path.length < 2) return;\n\n    this.ctx.strokeStyle = color;\n    this.ctx.lineWidth = lineWidth;\n    this.ctx.beginPath();\n\n    const start = path[0];\n    this.ctx.moveTo(\n      this.offsetX + (start.x + 0.5) * this.cellSize,\n      this.offsetY + (start.y + 0.5) * this.cellSize\n    );\n\n    for (let i = 1; i < path.length; i++) {\n      const point = path[i];\n      this.ctx.lineTo(\n        this.offsetX + (point.x + 0.5) * this.cellSize,\n        this.offsetY + (point.y + 0.5) * this.cellSize\n      );\n    }\n\n    this.ctx.stroke();\n  }\n\n  private drawCells(cells: Position[], color: string, alpha: number): void {\n    this.ctx.fillStyle = color;\n    this.ctx.globalAlpha = alpha;\n\n    for (const cell of cells) {\n      this.ctx.fillRect(\n        this.offsetX + cell.x * this.cellSize,\n        this.offsetY + cell.y * this.cellSize,\n        this.cellSize,\n        this.cellSize\n      );\n    }\n\n    this.ctx.globalAlpha = 1;\n  }\n}","import { SquareMazeGrid } from './objects/square-maze-grid';\nimport { MazeConfig } from './types/maze';\nimport { MazeSolver } from './objects/maze-solver';\nimport { MazeRenderer } from './objects/maze-renderer';\nimport { Solution } from './types/maze';\nimport { MazeGenerationError } from './errors/maze-errors';\n\nexport class MazeWorker {\n  private maze: SquareMazeGrid | null = null;\n  private solver: MazeSolver | null = null;\n  private solution: Solution | null = null;\n  private renderer: MazeRenderer | null = null;\n  private isGenerating: boolean = false;\n\n  constructor(private canvas: HTMLCanvasElement) {}\n\n  public generateMaze(width: number, height: number, seed: number): void {\n    this.solver = null;\n    this.solution = null;\n    this.isGenerating = true;\n    const config: MazeConfig = {\n      width,\n      height,\n      seed,\n      algorithm: 'kruskal',\n      renderer: 'webgl',\n      animationSpeed: 100,\n      cellSize: 20\n    };\n    this.maze = SquareMazeGrid.generate(config);\n    this.renderer = new MazeRenderer(this.canvas, this.maze);\n  }\n\n  public iterateMaze(): boolean {\n    if (this.maze) {\n      const done = this.maze.iterate();\n      if (this.renderer) {\n        this.renderer.render();\n      }\n      if (done) {\n        this.isGenerating = false;\n      }\n      return done;\n    }\n    return false;\n  }\n\n  public solveMaze(): void {\n    if (!this.maze) {\n      throw new MazeGenerationError('Maze not generated');\n    }\n    if (this.isGenerating) {\n      throw new MazeGenerationError('Maze generation not complete');\n    }\n    this.solver = new MazeSolver(this.maze);\n  }\n\n  public iterateSolution(): boolean {\n    if (this.solver) {\n      const done = this.solver.iterate();\n      if (this.renderer) {\n        this.renderer.renderSolvingProgress(\n          this.solver.getCurrentPath(),\n          this.solver.getOpenSet(),\n          this.solver.getClosedSet()\n        );\n      }\n      if (done) {\n        this.solution = this.solver.getSolution();\n        if (this.solution && this.renderer) {\n          this.renderer.renderSolution(this.solution);\n        }\n        this.solver = null;\n      }\n      return done;\n    }\n    return false;\n  }\n\n  public render(): void {\n    if (this.renderer) {\n      this.renderer.render();\n      if (this.solution) {\n        this.renderer.renderSolution(this.solution);\n      }\n    }\n  }\n}\n","import { MazeWorker } from './maze-worker';\nimport { MazeGenerationError } from './errors/maze-errors';\n\nclass App {\n  private worker: MazeWorker;\n  private animationFrameId: number | null = null;\n  private isGenerating = false;\n  private isSolving = false;\n\n  constructor() {\n    const canvas = document.getElementById('mazeCanvas') as HTMLCanvasElement;\n    if (!canvas) {\n      throw new Error('Canvas element not found');\n    }\n\n    // Set canvas size\n    canvas.width = 800;\n    canvas.height = 800;\n\n    this.worker = new MazeWorker(canvas);\n    this.setupEventListeners();\n  }\n\n  private setupEventListeners(): void {\n    const generateBtn = document.getElementById('generate');\n    const solveBtn = document.getElementById('solve');\n\n    if (generateBtn) {\n      generateBtn.addEventListener('click', () => this.handleGenerate());\n    }\n    if (solveBtn) {\n      solveBtn.addEventListener('click', () => this.handleSolve());\n    }\n  }\n\n  private handleGenerate(): void {\n    if (this.isGenerating || this.isSolving) return;\n\n    const width = parseInt((document.getElementById('width') as HTMLInputElement).value);\n    const height = parseInt((document.getElementById('height') as HTMLInputElement).value);\n    const seed = parseInt((document.getElementById('seed') as HTMLInputElement).value);\n\n    if (isNaN(width) || isNaN(height) || isNaN(seed)) {\n      alert('Please enter valid numbers for width, height, and seed');\n      return;\n    }\n\n    try {\n      this.isGenerating = true;\n      this.worker.generateMaze(width, height, seed);\n      this.animateGeneration();\n    } catch (error) {\n      this.isGenerating = false;\n      alert(error instanceof Error ? error.message : 'Failed to generate maze');\n    }\n  }\n\n  private handleSolve(): void {\n    if (this.isGenerating || this.isSolving) return;\n\n    try {\n      this.isSolving = true;\n      this.worker.solveMaze();\n      this.animateSolution();\n    } catch (error) {\n      this.isSolving = false;\n      if (error instanceof MazeGenerationError) {\n        alert(error.message);\n      } else {\n        alert('Failed to solve maze');\n      }\n    }\n  }\n\n  private animateGeneration(): void {\n    try {\n      const done = this.worker.iterateMaze();\n      if (done) {\n        this.isGenerating = false;\n        if (this.animationFrameId) {\n          cancelAnimationFrame(this.animationFrameId);\n          this.animationFrameId = null;\n        }\n      } else {\n        this.animationFrameId = requestAnimationFrame(() => this.animateGeneration());\n      }\n    } catch (error) {\n      this.isGenerating = false;\n      if (this.animationFrameId) {\n        cancelAnimationFrame(this.animationFrameId);\n        this.animationFrameId = null;\n      }\n      alert(error instanceof Error ? error.message : 'Failed to generate maze');\n    }\n  }\n\n  private animateSolution(): void {\n    try {\n      const done = this.worker.iterateSolution();\n      if (done) {\n        this.isSolving = false;\n        if (this.animationFrameId) {\n          cancelAnimationFrame(this.animationFrameId);\n          this.animationFrameId = null;\n        }\n      } else {\n        this.animationFrameId = requestAnimationFrame(() => this.animateSolution());\n      }\n    } catch (error) {\n      this.isSolving = false;\n      if (this.animationFrameId) {\n        cancelAnimationFrame(this.animationFrameId);\n        this.animationFrameId = null;\n      }\n      alert(error instanceof Error ? error.message : 'Failed to solve maze');\n    }\n  }\n}\n\n// Initialize the app when the DOM is loaded\ndocument.addEventListener('DOMContentLoaded', () => {\n  new App();\n});"],"names":["BaseMazeCell","constructor","_position","wallCount","this","__publicField","_walls","Array","fill","position","walls","visited","_visited","value","removeWall","index","length","hasWall","equals","other","x","y","toString","SquareWall","_SquareMazeCell","super","WALL_COUNT","wall","getNeighborPosition","Error","getOppositeWall","SquareMazeCell","_MazeWall","cellA","cellB","create","wallPool","pop","release","MAX_POOL_SIZE","push","MazeWall","DisjointSet","size","parent","from","_","i","rank","createSet","findSet","mergeSet","rootX","rootY","rankX","rankY","_PseudoRandom","seed","Date","now","nextInt","MULTIPLIER","INCREMENT","MODULUS","nextIntRange","min","max","nextDouble","nextDoubleRange","PseudoRandom","MazeError","message","code","name","MazeGenerationError","MazeSolvingError","InvalidConfigError","ConfigValidator","validate","config","validateDimensions","validateCellSize","validateAnimationSpeed","width","MIN_DIMENSION","MAX_DIMENSION","height","cellSize","MIN_CELL_SIZE","MAX_CELL_SIZE","animationSpeed","MIN_ANIMATION_SPEED","MAX_ANIMATION_SPEED","SquareMazeGrid","_cells","wallList","sets","initializeGrid","cells","Math","sqrt","getCell","getStartCell","startCell","getEndCell","endCell","cell","neighborPos","neighbor","addWall","some","w","iterate","cellAIndex","cellBIndex","removeWallsBetween","x1","y1","x2","y2","Bottom","Top","Right","Left","generate","grid","prng","j","createExitCells","outerWall","xPos","yPos","MazeSolver","maze","Set","initialize","startNode","g","h","heuristic","f","openSet","currentPath","abs","getNeighbors","node","neighbors","closedSet","has","solutionFound","current","reduce","filter","add","updateCurrentPath","gScore","hScore","fScore","existingNode","find","n","newNode","Object","assign","path","unshift","getCurrentPath","getOpenSet","map","getClosedSet","getSolution","start","end","MazeRenderer","canvas","context","getContext","ctx","calculateDimensions","padding","offsetX","offsetY","render","clearRect","drawMaze","renderSolution","solution","drawPath","renderSolvingProgress","drawCells","fillStyle","fillRect","drawCell","color","cellX","cellY","strokeStyle","lineWidth","beginPath","moveTo","lineTo","stroke","point","alpha","globalAlpha","MazeWorker","generateMaze","solver","isGenerating","algorithm","renderer","iterateMaze","done","solveMaze","iterateSolution","App","document","getElementById","worker","setupEventListeners","generateBtn","solveBtn","addEventListener","handleGenerate","handleSolve","isSolving","parseInt","isNaN","alert","animateGeneration","error","animateSolution","animationFrameId","cancelAnimationFrame","requestAnimationFrame"],"mappings":"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"}