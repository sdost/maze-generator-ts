{"version":3,"file":"maze-worker-D7H0vNhN.js","sources":["../src/objects/base-maze-cell.ts","../src/objects/square-maze-cell.ts","../src/objects/maze-wall.ts","../src/data-structures/disjoint-set.ts","../src/helpers/pseudo-random.ts","../src/errors/maze-errors.ts","../src/utils/config-validator.ts","../src/objects/square-maze-grid.ts","../src/objects/maze-solver.ts","../src/workers/maze-worker.ts"],"sourcesContent":["import { Position, MazeCell } from '../types/maze';\n\nexport abstract class BaseMazeCell implements MazeCell {\n  private readonly _walls: boolean[];\n  private _visited: boolean = false;\n\n  constructor(\n    private readonly _position: Position,\n    wallCount: number\n  ) {\n    this._walls = new Array(wallCount).fill(true);\n  }\n\n  public get position(): Position {\n    return this._position;\n  }\n\n  public get walls(): ReadonlyArray<boolean> {\n    return this._walls;\n  }\n\n  public get visited(): boolean {\n    return this._visited;\n  }\n\n  public set visited(value: boolean) {\n    this._visited = value;\n  }\n\n  public removeWall(index: number): void {\n    if (index >= 0 && index < this._walls.length) {\n      this._walls[index] = false;\n    }\n  }\n\n  public hasWall(index: number): boolean {\n    return index >= 0 && index < this._walls.length ? this._walls[index] : false;\n  }\n\n  public equals(other: BaseMazeCell): boolean {\n    return this._position.x === other._position.x && this._position.y === other._position.y;\n  }\n\n  public toString(): string {\n    return `Cell(${this._position.x}, ${this._position.y})`;\n  }\n}\n","import { Position } from '../types/maze';\nimport { BaseMazeCell } from './base-maze-cell';\n\nexport enum SquareWall {\n  Top = 0,\n  Right = 1,\n  Bottom = 2,\n  Left = 3,\n}\n\nexport class SquareMazeCell extends BaseMazeCell {\n  private static readonly WALL_COUNT = 4;\n\n  constructor(position: Position) {\n    super(position, SquareMazeCell.WALL_COUNT);\n  }\n\n  public removeWall(wall: SquareWall): void {\n    super.removeWall(wall);\n  }\n\n  public hasWall(wall: SquareWall): boolean {\n    return super.hasWall(wall);\n  }\n\n  public getNeighborPosition(wall: SquareWall): Position {\n    const { x, y } = this.position;\n    switch (wall) {\n      case SquareWall.Top:\n        return { x, y: y - 1 };\n      case SquareWall.Right:\n        return { x: x + 1, y };\n      case SquareWall.Bottom:\n        return { x, y: y + 1 };\n      case SquareWall.Left:\n        return { x: x - 1, y };\n      default:\n        throw new Error(`Invalid wall direction: ${wall}`);\n    }\n  }\n\n  public static getOppositeWall(wall: SquareWall): SquareWall {\n    switch (wall) {\n      case SquareWall.Top:\n        return SquareWall.Bottom;\n      case SquareWall.Right:\n        return SquareWall.Left;\n      case SquareWall.Bottom:\n        return SquareWall.Top;\n      case SquareWall.Left:\n        return SquareWall.Right;\n      default:\n        throw new Error(`Invalid wall direction: ${wall}`);\n    }\n  }\n}\n","import { SquareMazeCell } from './square-maze-cell';\n\ninterface MutableMazeWall extends MazeWall {\n  cellA: SquareMazeCell;\n  cellB: SquareMazeCell;\n}\n\nexport class MazeWall {\n  private static readonly wallPool: MazeWall[] = [];\n  private static readonly MAX_POOL_SIZE = 10000;\n\n  private constructor(\n    public readonly cellA: SquareMazeCell,\n    public readonly cellB: SquareMazeCell\n  ) {}\n\n  public static create(cellA: SquareMazeCell, cellB: SquareMazeCell): MazeWall {\n    if (this.wallPool.length > 0) {\n      const wall = this.wallPool.pop()! as MutableMazeWall;\n      wall.cellA = cellA;\n      wall.cellB = cellB;\n      return wall;\n    }\n    return new MazeWall(cellA, cellB);\n  }\n\n  public static release(wall: MazeWall): void {\n    if (this.wallPool.length < this.MAX_POOL_SIZE) {\n      this.wallPool.push(wall);\n    }\n  }\n\n  public equals(other: MazeWall): boolean {\n    return (\n      (this.cellA === other.cellA && this.cellB === other.cellB) ||\n      (this.cellA === other.cellB && this.cellB === other.cellA)\n    );\n  }\n\n  public toString(): string {\n    return `Wall(${this.cellA.toString()} - ${this.cellB.toString()})`;\n  }\n}\n","export class DisjointSet {\n  private parent: number[];\n  private rank: number[];\n\n  constructor(size: number) {\n    this.parent = Array.from({ length: size }, (_, i) => i);\n    this.rank = new Array(size).fill(0);\n  }\n\n  public createSet(x: number): void {\n    this.parent[x] = x;\n    this.rank[x] = 0;\n  }\n\n  public findSet(x: number): number {\n    if (x < 0 || x >= this.parent.length) {\n      throw new Error('Element not found in any set');\n    }\n\n    if (this.parent[x] !== x) {\n      this.parent[x] = this.findSet(this.parent[x]);\n    }\n\n    return this.parent[x];\n  }\n\n  public mergeSet(x: number, y: number): void {\n    const rootX = this.findSet(x);\n    const rootY = this.findSet(y);\n\n    if (rootX === rootY) {\n      return;\n    }\n\n    const rankX = this.rank[rootX];\n    const rankY = this.rank[rootY];\n\n    if (rankX < rankY) {\n      this.parent[rootX] = rootY;\n    } else if (rankX > rankY) {\n      this.parent[rootY] = rootX;\n    } else {\n      this.parent[rootY] = rootX;\n      this.rank[rootX] = rankX + 1;\n    }\n  }\n}\n","export class PseudoRandom {\n  private static readonly MULTIPLIER = 1664525;\n  private static readonly INCREMENT = 1013904223;\n  private static readonly MODULUS = 4294967296; // 2^32\n\n  private seed: number;\n\n  constructor(seed: string | number | null = Date.now()) {\n    if (seed === null) {\n      this.seed = Date.now();\n    } else if (typeof seed === 'string') {\n      // Convert string to number using a simple hash function\n      this.seed = this.hashString(seed);\n    } else {\n      this.seed = seed;\n    }\n  }\n\n  private hashString(str: string): number {\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n      const char = str.charCodeAt(i);\n      hash = (hash << 5) - hash + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    return Math.abs(hash);\n  }\n\n  public nextInt(): number {\n    this.seed =\n      (this.seed * PseudoRandom.MULTIPLIER + PseudoRandom.INCREMENT) % PseudoRandom.MODULUS;\n    return this.seed;\n  }\n\n  public nextIntRange(min: number, max: number): number {\n    const range = max - min + 1;\n    const maxValue = PseudoRandom.MODULUS - (PseudoRandom.MODULUS % range);\n    let value: number;\n    do {\n      value = this.nextInt();\n    } while (value >= maxValue);\n    return min + (value % range);\n  }\n\n  public nextDouble(): number {\n    return this.nextInt() / PseudoRandom.MODULUS;\n  }\n\n  public nextDoubleRange(min: number, max: number): number {\n    return min + this.nextDouble() * (max - min);\n  }\n}\n","export class MazeError extends Error {\n  constructor(\n    message: string,\n    public readonly code: string\n  ) {\n    super(message);\n    this.name = 'MazeError';\n  }\n}\n\nexport class MazeGenerationError extends MazeError {\n  constructor(message: string) {\n    super(message, 'MAZE_GENERATION_ERROR');\n    this.name = 'MazeGenerationError';\n  }\n}\n\nexport class MazeSolvingError extends MazeError {\n  constructor(message: string) {\n    super(message, 'MAZE_SOLVING_ERROR');\n    this.name = 'MazeSolvingError';\n  }\n}\n\nexport class MazeRenderingError extends MazeError {\n  constructor(message: string) {\n    super(message, 'MAZE_RENDERING_ERROR');\n    this.name = 'MazeRenderingError';\n  }\n}\n\nexport class InvalidConfigError extends MazeError {\n  constructor(message: string) {\n    super(message, 'INVALID_CONFIG_ERROR');\n    this.name = 'InvalidConfigError';\n  }\n}\n","import { MazeConfig } from '../types/maze';\nimport { InvalidConfigError } from '../errors/maze-errors';\n\nexport class ConfigValidator {\n  private static readonly MIN_DIMENSION = 2;\n  private static readonly MAX_DIMENSION = 1000;\n  private static readonly MIN_CELL_SIZE = 4;\n  private static readonly MAX_CELL_SIZE = 100;\n  private static readonly MIN_ANIMATION_SPEED = 1;\n  private static readonly MAX_ANIMATION_SPEED = 1000;\n\n  public static validate(config: MazeConfig): void {\n    this.validateDimensions(config);\n    this.validateCellSize(config);\n    this.validateAnimationSpeed(config);\n  }\n\n  private static validateDimensions(config: MazeConfig): void {\n    if (config.width < this.MIN_DIMENSION || config.width > this.MAX_DIMENSION) {\n      throw new InvalidConfigError(\n        `Width must be between ${this.MIN_DIMENSION} and ${this.MAX_DIMENSION}`\n      );\n    }\n\n    if (config.height < this.MIN_DIMENSION || config.height > this.MAX_DIMENSION) {\n      throw new InvalidConfigError(\n        `Height must be between ${this.MIN_DIMENSION} and ${this.MAX_DIMENSION}`\n      );\n    }\n  }\n\n  private static validateCellSize(config: MazeConfig): void {\n    if (config.cellSize < this.MIN_CELL_SIZE || config.cellSize > this.MAX_CELL_SIZE) {\n      throw new InvalidConfigError(\n        `Cell size must be between ${this.MIN_CELL_SIZE} and ${this.MAX_CELL_SIZE}`\n      );\n    }\n  }\n\n  private static validateAnimationSpeed(config: MazeConfig): void {\n    if (\n      config.animationSpeed < this.MIN_ANIMATION_SPEED ||\n      config.animationSpeed > this.MAX_ANIMATION_SPEED\n    ) {\n      throw new InvalidConfigError(\n        `Animation speed must be between ${this.MIN_ANIMATION_SPEED} and ${this.MAX_ANIMATION_SPEED}`\n      );\n    }\n  }\n}\n","import { MazeGrid } from '../types/maze';\nimport { SquareMazeCell, SquareWall } from './square-maze-cell';\nimport { MazeWall } from './maze-wall';\nimport { DisjointSet } from '../data-structures/disjoint-set';\nimport { PseudoRandom } from '../helpers/pseudo-random';\nimport { ConfigValidator } from '../utils/config-validator';\nimport { MazeConfig } from '../types/maze';\nimport { MazeGenerationError } from '../errors/maze-errors';\n\nexport class SquareMazeGrid implements MazeGrid {\n  private readonly _cells: SquareMazeCell[];\n  private readonly wallList: MazeWall[];\n  private readonly sets: DisjointSet;\n  private startCell: SquareMazeCell | null = null;\n  private endCell: SquareMazeCell | null = null;\n\n  constructor(config: MazeConfig) {\n    ConfigValidator.validate(config);\n    this._cells = new Array<SquareMazeCell>(config.width * config.height);\n    this.wallList = [];\n    this.sets = new DisjointSet(config.width * config.height);\n    this.initializeGrid(config);\n  }\n\n  public get cells(): ReadonlyArray<SquareMazeCell> {\n    return this._cells;\n  }\n\n  public get width(): number {\n    return this._cells.length > 0 ? Math.sqrt(this._cells.length) : 0;\n  }\n\n  public get height(): number {\n    return this.width;\n  }\n\n  public getCell(x: number, y: number): SquareMazeCell | null {\n    if (x < 0 || x >= this.width || y < 0 || y >= this.height) {\n      return null;\n    }\n    return this._cells[x + y * this.width];\n  }\n\n  public getStartCell(): SquareMazeCell {\n    if (!this.startCell) {\n      throw new MazeGenerationError('Start cell not set');\n    }\n    return this.startCell;\n  }\n\n  public getEndCell(): SquareMazeCell {\n    if (!this.endCell) {\n      throw new MazeGenerationError('End cell not set');\n    }\n    return this.endCell;\n  }\n\n  public setStartCell(cell: SquareMazeCell): void {\n    this.startCell = cell;\n  }\n\n  public setEndCell(cell: SquareMazeCell): void {\n    this.endCell = cell;\n  }\n\n  private initializeGrid(config: MazeConfig): void {\n    // Initialize cells\n    for (let y = 0; y < config.height; y++) {\n      for (let x = 0; x < config.width; x++) {\n        const cell = new SquareMazeCell({ x, y });\n        this._cells[x + y * config.width] = cell;\n        this.sets.createSet(x + y * config.width);\n      }\n    }\n\n    // Initialize walls\n    for (let y = 0; y < config.height; y++) {\n      for (let x = 0; x < config.width; x++) {\n        const cell = this.getCell(x, y)!;\n\n        // Add walls to neighbors\n        if (x < config.width - 1) {\n          const rightCell = this.getCell(x + 1, y)!;\n          this.addWall(cell, rightCell);\n        }\n        if (y < config.height - 1) {\n          const bottomCell = this.getCell(x, y + 1)!;\n          this.addWall(cell, bottomCell);\n        }\n      }\n    }\n  }\n\n  private addWall(cellA: SquareMazeCell, cellB: SquareMazeCell): void {\n    const wall = MazeWall.create(cellA, cellB);\n    if (!this.wallList.some((w) => w.equals(wall))) {\n      this.wallList.push(wall);\n    } else {\n      MazeWall.release(wall);\n    }\n  }\n\n  public iterate(): boolean {\n    if (this.wallList.length === 0) {\n      return true;\n    }\n\n    const wall = this.wallList.pop()!;\n    const cellAIndex = wall.cellA.position.x + wall.cellA.position.y * this.width;\n    const cellBIndex = wall.cellB.position.x + wall.cellB.position.y * this.width;\n    if (this.sets.findSet(cellAIndex) !== this.sets.findSet(cellBIndex)) {\n      this.sets.mergeSet(cellAIndex, cellBIndex);\n      this.removeWallsBetween(wall.cellA, wall.cellB);\n    }\n\n    MazeWall.release(wall);\n    return false;\n  }\n\n  private removeWallsBetween(cellA: SquareMazeCell, cellB: SquareMazeCell): void {\n    const { x: x1, y: y1 } = cellA.position;\n    const { x: x2, y: y2 } = cellB.position;\n\n    if (x1 === x2) {\n      if (y1 < y2) {\n        cellA.removeWall(SquareWall.Bottom);\n        cellB.removeWall(SquareWall.Top);\n      } else {\n        cellA.removeWall(SquareWall.Top);\n        cellB.removeWall(SquareWall.Bottom);\n      }\n    } else {\n      if (x1 < x2) {\n        cellA.removeWall(SquareWall.Right);\n        cellB.removeWall(SquareWall.Left);\n      } else {\n        cellA.removeWall(SquareWall.Left);\n        cellB.removeWall(SquareWall.Right);\n      }\n    }\n  }\n\n  public static generate(config: MazeConfig): SquareMazeGrid {\n    const grid = new SquareMazeGrid(config);\n    const prng = new PseudoRandom(config.seed);\n\n    // Shuffle walls using Fisher-Yates algorithm with seeded random\n    for (let i = grid.wallList.length - 1; i > 0; i--) {\n      const j = prng.nextIntRange(0, i);\n      [grid.wallList[i], grid.wallList[j]] = [grid.wallList[j], grid.wallList[i]];\n    }\n\n    // Create exit cells immediately\n    grid.createExitCells(prng);\n\n    return grid;\n  }\n\n  private createExitCells(prng: PseudoRandom): void {\n    const outerWall: SquareWall = prng.nextIntRange(0, 3);\n    let xPos = 0;\n    let yPos = 0;\n\n    // Set start cell\n    switch (outerWall) {\n      case SquareWall.Top:\n        xPos = prng.nextIntRange(0, this.width - 1);\n        yPos = 0;\n        break;\n      case SquareWall.Right:\n        yPos = prng.nextIntRange(0, this.height - 1);\n        xPos = this.width - 1;\n        break;\n      case SquareWall.Bottom:\n        xPos = prng.nextIntRange(0, this.width - 1);\n        yPos = this.height - 1;\n        break;\n      case SquareWall.Left:\n        yPos = prng.nextIntRange(0, this.height - 1);\n        xPos = 0;\n        break;\n    }\n\n    this.startCell = this.getCell(xPos, yPos);\n\n    // Set end cell on opposite wall\n    switch (outerWall) {\n      case SquareWall.Top:\n        xPos = prng.nextIntRange(0, this.width - 1);\n        yPos = this.height - 1;\n        break;\n      case SquareWall.Right:\n        yPos = prng.nextIntRange(0, this.height - 1);\n        xPos = 0;\n        break;\n      case SquareWall.Bottom:\n        xPos = prng.nextIntRange(0, this.width - 1);\n        yPos = 0;\n        break;\n      case SquareWall.Left:\n        yPos = prng.nextIntRange(0, this.height - 1);\n        xPos = this.width - 1;\n        break;\n    }\n\n    this.endCell = this.getCell(xPos, yPos);\n  }\n}\n","import { MazeGrid, Position, Solution } from '../types/maze';\nimport { SquareMazeCell } from './square-maze-cell';\nimport { MazeSolvingError } from '../errors/maze-errors';\n\ninterface Node {\n  cell: SquareMazeCell;\n  parent: Node | null;\n  g: number; // Cost from start to current\n  h: number; // Heuristic (estimated cost from current to end)\n  f: number; // Total cost (g + h)\n}\n\nexport class MazeSolver {\n  private openSet: Node[] = [];\n  private closedSet: Set<SquareMazeCell> = new Set();\n  private startCell: SquareMazeCell;\n  private endCell: SquareMazeCell;\n  private current: Node | null = null;\n  private solutionFound: boolean = false;\n  private currentPath: Position[] = [];\n\n  constructor(private maze: MazeGrid) {\n    this.startCell = maze.getStartCell() as SquareMazeCell;\n    this.endCell = maze.getEndCell() as SquareMazeCell;\n    this.initialize();\n  }\n\n  private initialize(): void {\n    // Create initial node for start cell\n    const startNode: Node = {\n      cell: this.startCell,\n      parent: null,\n      g: 0,\n      h: this.heuristic(this.startCell),\n      f: this.heuristic(this.startCell),\n    };\n\n    this.openSet = [startNode];\n    this.closedSet.clear();\n    this.current = null;\n    this.solutionFound = false;\n    this.currentPath = [this.startCell.position];\n  }\n\n  private heuristic(cell: SquareMazeCell): number {\n    // Manhattan distance to end cell\n    return (\n      Math.abs(cell.position.x - this.endCell.position.x) +\n      Math.abs(cell.position.y - this.endCell.position.y)\n    );\n  }\n\n  private getNeighbors(node: Node): SquareMazeCell[] {\n    const neighbors: SquareMazeCell[] = [];\n    const { cell } = node;\n\n    // Check all four directions\n    for (let wall = 0; wall < 4; wall++) {\n      // If there's no wall in this direction, we can move there\n      if (!cell.hasWall(wall)) {\n        const neighborPos = cell.getNeighborPosition(wall);\n        const neighbor = this.maze.getCell(neighborPos.x, neighborPos.y);\n\n        // Only add valid neighbors that haven't been visited\n        if (neighbor && !this.closedSet.has(neighbor as SquareMazeCell)) {\n          neighbors.push(neighbor as SquareMazeCell);\n        }\n      }\n    }\n\n    return neighbors;\n  }\n\n  private updateCurrentPath(): void {\n    this.currentPath = [];\n    let node: Node | null = this.current;\n    while (node) {\n      this.currentPath.unshift(node.cell.position);\n      node = node.parent;\n    }\n  }\n\n  public getCurrentPath(): Position[] {\n    return this.currentPath;\n  }\n\n  public getOpenSet(): Position[] {\n    return this.openSet.map((node) => node.cell.position);\n  }\n\n  public getClosedSet(): Position[] {\n    return Array.from(this.closedSet).map((cell) => cell.position);\n  }\n\n  public iterate(): boolean {\n    // If we've already found a solution, return true\n    if (this.solutionFound) {\n      return true;\n    }\n\n    // If there are no more nodes to explore, no solution exists\n    if (this.openSet.length === 0) {\n      throw new MazeSolvingError('No solution exists for this maze');\n    }\n\n    // Get node with lowest f score\n    this.current = this.openSet.reduce(\n      (min, node) => (node.f < min.f ? node : min),\n      this.openSet[0]\n    );\n\n    // Remove current from open set\n    this.openSet = this.openSet.filter((node) => node !== this.current);\n\n    // Add current to closed set\n    this.closedSet.add(this.current.cell);\n\n    // Update current path for animation\n    this.updateCurrentPath();\n\n    // Check if we reached the end\n    if (this.current.cell === this.endCell) {\n      this.solutionFound = true;\n      return true;\n    }\n\n    // Process neighbors\n    for (const neighbor of this.getNeighbors(this.current)) {\n      const gScore = this.current.g + 1;\n      const hScore = this.heuristic(neighbor);\n      const fScore = gScore + hScore;\n\n      // Check if this path to neighbor is better than previous ones\n      const existingNode = this.openSet.find((n) => n.cell === neighbor);\n      if (!existingNode || gScore < existingNode.g) {\n        const newNode: Node = {\n          cell: neighbor,\n          parent: this.current,\n          g: gScore,\n          h: hScore,\n          f: fScore,\n        };\n\n        if (!existingNode) {\n          this.openSet.push(newNode);\n        } else {\n          Object.assign(existingNode, newNode);\n        }\n      }\n    }\n\n    return false;\n  }\n\n  public getSolution(): Solution {\n    if (!this.solutionFound || !this.current || this.current.cell !== this.endCell) {\n      throw new MazeSolvingError('No solution has been found yet');\n    }\n\n    return {\n      path: this.currentPath,\n      start: this.startCell.position,\n      end: this.endCell.position,\n    };\n  }\n}\n","import { MazeConfig, Solution, Position } from '../types/maze';\nimport { SquareMazeGrid } from '../objects/square-maze-grid';\nimport { MazeSolver } from '../objects/maze-solver';\n\ninterface WorkerMessage {\n  type: 'generate' | 'iterate' | 'solve' | 'iterateSolution';\n  payload?: MazeConfig;\n}\n\ninterface WorkerResponse {\n  type: 'progress' | 'complete' | 'error';\n  payload: {\n    type?: string;\n    done?: boolean;\n    maze?: {\n      _cells: Array<{\n        position: Position;\n        walls: boolean[];\n      }>;\n      startCell?: { position: Position };\n      endCell?: { position: Position };\n    };\n    solution?: Solution;\n    currentPath?: Position[];\n    openSet?: Position[];\n    closedSet?: Position[];\n    message?: string;\n    currentState?: {\n      _cells: Array<{\n        position: Position;\n        walls: boolean[];\n      }>;\n      startCell?: { position: Position };\n      endCell?: { position: Position };\n    };\n  };\n}\n\nclass MazeWorker {\n  private maze: SquareMazeGrid | null = null;\n  private solver: MazeSolver | null = null;\n  private isGenerating: boolean = false;\n\n  constructor() {\n    this.setupMessageHandler();\n  }\n\n  private setupMessageHandler(): void {\n    self.onmessage = (event: MessageEvent<WorkerMessage>): void => {\n      try {\n        const { type, payload } = event.data;\n        switch (type) {\n          case 'generate':\n            this.handleGenerate(payload as MazeConfig);\n            break;\n          case 'iterate':\n            this.handleIterate();\n            break;\n          case 'solve':\n            this.handleSolve();\n            break;\n          case 'iterateSolution':\n            this.handleIterateSolution();\n            break;\n          default:\n            this.sendError(`Unknown message type: ${type}`);\n        }\n      } catch (error) {\n        console.error('Worker error:', error);\n        this.sendError(error instanceof Error ? error.message : 'Unknown error');\n      }\n    };\n  }\n\n  private serializeMaze(maze: SquareMazeGrid): WorkerResponse['payload']['maze'] {\n    return {\n      _cells: maze.cells.map((cell) => ({\n        position: { x: cell.position.x, y: cell.position.y },\n        walls: Array.from(cell.walls),\n      })),\n      startCell: maze.getStartCell()\n        ? {\n            position: { x: maze.getStartCell().position.x, y: maze.getStartCell().position.y },\n          }\n        : undefined,\n      endCell: maze.getEndCell()\n        ? {\n            position: { x: maze.getEndCell().position.x, y: maze.getEndCell().position.y },\n          }\n        : undefined,\n    };\n  }\n\n  private handleGenerate(config: MazeConfig): void {\n    try {\n      this.solver = null;\n      this.isGenerating = true;\n      this.maze = SquareMazeGrid.generate(config);\n      const serializedMaze = this.serializeMaze(this.maze);\n      this.sendProgress('generate', {\n        done: false,\n        currentState: serializedMaze,\n      });\n    } catch (error) {\n      console.error('Error generating maze:', error);\n      this.sendError(error instanceof Error ? error.message : 'Failed to generate maze');\n    }\n  }\n\n  private handleIterate(): void {\n    if (!this.maze) {\n      this.sendError('Maze not generated');\n      return;\n    }\n\n    try {\n      const done = this.maze.iterate();\n      const serializedMaze = this.serializeMaze(this.maze);\n      this.sendProgress('iterate', {\n        done,\n        currentState: serializedMaze,\n      });\n\n      if (done) {\n        this.isGenerating = false;\n        this.sendComplete('generate', { maze: serializedMaze });\n      }\n    } catch (error) {\n      console.error('Error during iteration:', error);\n      this.sendError(error instanceof Error ? error.message : 'Failed to iterate maze');\n    }\n  }\n\n  private handleSolve(): void {\n    if (!this.maze) {\n      this.sendError('Maze not generated');\n      return;\n    }\n    if (this.isGenerating) {\n      this.sendError('Maze generation not complete');\n      return;\n    }\n\n    try {\n      this.solver = new MazeSolver(this.maze);\n\n      // Send initial state\n      const currentPath = this.solver.getCurrentPath();\n      const openSet = this.solver.getOpenSet();\n      const closedSet = this.solver.getClosedSet();\n\n      this.sendProgress('solve', {\n        done: false,\n        currentPath,\n        openSet,\n        closedSet,\n      });\n    } catch (error) {\n      console.error('Error initializing solver:', error);\n      this.sendError(error instanceof Error ? error.message : 'Failed to initialize solver');\n    }\n  }\n\n  private handleIterateSolution(): void {\n    if (!this.solver) {\n      this.sendError('Solver not initialized');\n      return;\n    }\n\n    try {\n      const done = this.solver.iterate();\n\n      // Always send progress, even if done\n      const currentPath = this.solver.getCurrentPath();\n      const openSet = this.solver.getOpenSet();\n      const closedSet = this.solver.getClosedSet();\n\n      this.sendProgress('iterateSolution', {\n        done,\n        currentPath,\n        openSet,\n        closedSet,\n      });\n\n      if (done) {\n        try {\n          const solution = this.solver.getSolution();\n          this.sendComplete('solve', { solution });\n          this.solver = null;\n        } catch (error) {\n          console.error('Error getting solution:', error);\n          this.sendError(error instanceof Error ? error.message : 'Failed to get solution');\n        }\n      }\n    } catch (error) {\n      console.error('Error during solution iteration:', error);\n      this.sendError(error instanceof Error ? error.message : 'Failed to iterate solution');\n    }\n  }\n\n  private sendProgress(type: string, payload: WorkerResponse['payload']): void {\n    self.postMessage({\n      type: 'progress',\n      payload: { type, ...payload },\n    } as WorkerResponse);\n  }\n\n  private sendComplete(type: string, payload: WorkerResponse['payload']): void {\n    self.postMessage({\n      type: 'complete',\n      payload: { type, ...payload },\n    } as WorkerResponse);\n  }\n\n  private sendError(message: string): void {\n    console.error('Sending error:', message);\n    self.postMessage({\n      type: 'error',\n      payload: { message },\n    } as WorkerResponse);\n  }\n}\n\n// Initialize the worker\nnew MazeWorker();\n"],"names":["BaseMazeCell","constructor","_position","wallCount","this","__publicField","_walls","Array","fill","position","walls","visited","_visited","value","removeWall","index","length","hasWall","equals","other","x","y","toString","SquareWall","_SquareMazeCell","super","WALL_COUNT","wall","getNeighborPosition","Error","getOppositeWall","SquareMazeCell","_MazeWall","cellA","cellB","create","wallPool","pop","release","MAX_POOL_SIZE","push","MazeWall","DisjointSet","size","parent","from","_","i","rank","createSet","findSet","mergeSet","rootX","rootY","rankX","rankY","_PseudoRandom","seed","Date","now","hashString","str","hash","charCodeAt","Math","abs","nextInt","MULTIPLIER","INCREMENT","MODULUS","nextIntRange","min","max","range","maxValue","nextDouble","nextDoubleRange","PseudoRandom","MazeError","message","code","name","MazeGenerationError","MazeSolvingError","InvalidConfigError","ConfigValidator","validate","config","validateDimensions","validateCellSize","validateAnimationSpeed","width","MIN_DIMENSION","MAX_DIMENSION","height","cellSize","MIN_CELL_SIZE","MAX_CELL_SIZE","animationSpeed","MIN_ANIMATION_SPEED","MAX_ANIMATION_SPEED","SquareMazeGrid","_cells","wallList","sets","initializeGrid","cells","sqrt","getCell","getStartCell","startCell","getEndCell","endCell","setStartCell","cell","setEndCell","rightCell","addWall","bottomCell","some","w","iterate","cellAIndex","cellBIndex","removeWallsBetween","x1","y1","x2","y2","Bottom","Top","Right","Left","generate","grid","prng","j","createExitCells","outerWall","xPos","yPos","MazeSolver","maze","Set","initialize","startNode","g","h","heuristic","f","openSet","closedSet","clear","current","solutionFound","currentPath","getNeighbors","node","neighbors","neighborPos","neighbor","has","updateCurrentPath","unshift","getCurrentPath","getOpenSet","map","getClosedSet","reduce","filter","add","gScore","hScore","fScore","existingNode","find","n","newNode","Object","assign","getSolution","path","start","end","setupMessageHandler","self","onmessage","event","type","payload","data","handleGenerate","handleIterate","handleSolve","handleIterateSolution","sendError","error","serializeMaze","solver","isGenerating","serializedMaze","sendProgress","done","currentState","sendComplete","solution","postMessage"],"mappings":"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"}